{"version":3,"file":"calendar-core.esm.min.js","sources":["../../core/core/timezone/TimezoneManager.js","../../core/core/events/Event.js","../../core/core/calendar/DateUtils.js","../../core/core/events/RecurrenceEngine.js","../../core/core/performance/LRUCache.js","../../core/core/performance/PerformanceOptimizer.js","../../core/core/conflicts/ConflictDetector.js","../../core/core/events/EventStore.js","../../core/core/state/StateManager.js","../../core/core/calendar/Calendar.js","../../core/index.js"],"sourcesContent":["/**\n * TimezoneManager - Comprehensive timezone handling for global calendar operations\n * Handles timezone conversions, DST transitions, and IANA timezone database\n *\n * Critical for Salesforce orgs spanning multiple timezones\n */\n\nexport class TimezoneManager {\n    constructor() {\n        // Cache timezone offsets for performance\n        this.offsetCache = new Map();\n        this.dstCache = new Map();\n\n        // Common timezone abbreviations to IANA mapping\n        this.timezoneAbbreviations = {\n            'EST': 'America/New_York',\n            'EDT': 'America/New_York',\n            'CST': 'America/Chicago',\n            'CDT': 'America/Chicago',\n            'MST': 'America/Denver',\n            'MDT': 'America/Denver',\n            'PST': 'America/Los_Angeles',\n            'PDT': 'America/Los_Angeles',\n            'GMT': 'Europe/London',\n            'BST': 'Europe/London',\n            'CET': 'Europe/Paris',\n            'CEST': 'Europe/Paris',\n            'JST': 'Asia/Tokyo',\n            'IST': 'Asia/Kolkata',\n            'AEST': 'Australia/Sydney',\n            'AEDT': 'Australia/Sydney'\n        };\n\n        // IANA timezone offset rules (simplified - in production would use Intl API or timezone database)\n        this.timezoneOffsets = {\n            'UTC': 0,\n            'America/New_York': -5,\n            'America/Chicago': -6,\n            'America/Denver': -7,\n            'America/Los_Angeles': -8,\n            'America/Phoenix': -7, // No DST\n            'Europe/London': 0,\n            'Europe/Paris': 1,\n            'Europe/Berlin': 1,\n            'Asia/Tokyo': 9,\n            'Asia/Shanghai': 8,\n            'Asia/Kolkata': 5.5,\n            'Australia/Sydney': 10,\n            'Pacific/Auckland': 12\n        };\n\n        // DST rules (simplified - real implementation would be more complex)\n        this.dstRules = {\n            'America/New_York': { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 1 },\n            'America/Chicago': { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 1 },\n            'America/Denver': { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 1 },\n            'America/Los_Angeles': { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 1 },\n            'Europe/London': { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 1 },\n            'Europe/Paris': { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 1 },\n            'Australia/Sydney': { start: { month: 10, week: 1, day: 0 }, end: { month: 4, week: 1, day: 0 }, offset: 1 }\n        };\n    }\n\n    /**\n     * Convert date from one timezone to another\n     * @param {Date} date - Date to convert\n     * @param {string} fromTimezone - Source timezone (IANA identifier)\n     * @param {string} toTimezone - Target timezone (IANA identifier)\n     * @returns {Date} Converted date\n     */\n    convertTimezone(date, fromTimezone, toTimezone) {\n        if (!date) return null;\n        if (fromTimezone === toTimezone) return new Date(date);\n\n        // Get offset difference\n        const fromOffset = this.getTimezoneOffset(date, fromTimezone);\n        const toOffset = this.getTimezoneOffset(date, toTimezone);\n        const offsetDiff = (toOffset - fromOffset) * 60 * 1000; // Convert to milliseconds\n\n        return new Date(date.getTime() + offsetDiff);\n    }\n\n    /**\n     * Convert date to UTC\n     * @param {Date} date - Date in local timezone\n     * @param {string} timezone - Source timezone\n     * @returns {Date} Date in UTC\n     */\n    toUTC(date, timezone) {\n        if (!date) return null;\n        if (timezone === 'UTC') return new Date(date);\n\n        const offset = this.getTimezoneOffset(date, timezone);\n        return new Date(date.getTime() - (offset * 60 * 1000));\n    }\n\n    /**\n     * Convert UTC date to timezone\n     * @param {Date} utcDate - Date in UTC\n     * @param {string} timezone - Target timezone\n     * @returns {Date} Date in specified timezone\n     */\n    fromUTC(utcDate, timezone) {\n        if (!utcDate) return null;\n        if (timezone === 'UTC') return new Date(utcDate);\n\n        const offset = this.getTimezoneOffset(utcDate, timezone);\n        return new Date(utcDate.getTime() + (offset * 60 * 1000));\n    }\n\n    /**\n     * Get timezone offset in minutes\n     * @param {Date} date - Date to check (for DST calculation)\n     * @param {string} timezone - Timezone identifier\n     * @returns {number} Offset in minutes from UTC\n     */\n    getTimezoneOffset(date, timezone) {\n        // Check cache first\n        const cacheKey = `${timezone}_${date.getFullYear()}_${date.getMonth()}_${date.getDate()}`;\n        if (this.offsetCache.has(cacheKey)) {\n            return this.offsetCache.get(cacheKey);\n        }\n\n        // Try using Intl API if available (best option for browser/Node.js environments)\n        if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {\n            try {\n                const formatter = new Intl.DateTimeFormat('en-US', {\n                    timeZone: timezone,\n                    year: 'numeric',\n                    month: '2-digit',\n                    day: '2-digit',\n                    hour: '2-digit',\n                    minute: '2-digit',\n                    second: '2-digit',\n                    hour12: false\n                });\n\n                // Create same date in target timezone\n                const parts = formatter.formatToParts(date);\n                const tzDate = new Date(\n                    parts.find(p => p.type === 'year').value,\n                    parts.find(p => p.type === 'month').value - 1,\n                    parts.find(p => p.type === 'day').value,\n                    parts.find(p => p.type === 'hour').value,\n                    parts.find(p => p.type === 'minute').value,\n                    parts.find(p => p.type === 'second').value\n                );\n\n                const offset = (tzDate.getTime() - date.getTime()) / (1000 * 60);\n                this.offsetCache.set(cacheKey, -offset);\n                return -offset;\n            } catch (e) {\n                // Fallback to manual calculation\n            }\n        }\n\n        // Fallback: Manual calculation\n        let baseOffset = (this.timezoneOffsets[timezone] || 0) * 60;\n\n        // Apply DST if applicable\n        if (this.isDST(date, timezone)) {\n            const dstRule = this.dstRules[timezone];\n            if (dstRule) {\n                baseOffset += dstRule.offset * 60;\n            }\n        }\n\n        this.offsetCache.set(cacheKey, baseOffset);\n        return baseOffset;\n    }\n\n    /**\n     * Check if date is in DST for given timezone\n     * @param {Date} date - Date to check\n     * @param {string} timezone - Timezone identifier\n     * @returns {boolean} True if in DST\n     */\n    isDST(date, timezone) {\n        const dstRule = this.dstRules[timezone];\n        if (!dstRule) return false;\n\n        const year = date.getFullYear();\n        const dstStart = this.getNthWeekdayOfMonth(year, dstRule.start.month, dstRule.start.week, dstRule.start.day);\n        const dstEnd = this.getNthWeekdayOfMonth(year, dstRule.end.month, dstRule.end.week, dstRule.end.day);\n\n        // Handle Southern Hemisphere (DST crosses year boundary)\n        if (dstStart > dstEnd) {\n            return date >= dstStart || date < dstEnd;\n        }\n\n        return date >= dstStart && date < dstEnd;\n    }\n\n    /**\n     * Get nth weekday of month\n     * @private\n     */\n    getNthWeekdayOfMonth(year, month, week, dayOfWeek) {\n        const date = new Date(year, month, 1);\n        const firstDay = date.getDay();\n\n        let dayOffset = dayOfWeek - firstDay;\n        if (dayOffset < 0) dayOffset += 7;\n\n        if (week > 0) {\n            // Nth occurrence from start\n            date.setDate(1 + dayOffset + (week - 1) * 7);\n        } else {\n            // Nth occurrence from end\n            const lastDay = new Date(year, month + 1, 0).getDate();\n            date.setDate(lastDay);\n            const lastDayOfWeek = date.getDay();\n            let offset = lastDayOfWeek - dayOfWeek;\n            if (offset < 0) offset += 7;\n            date.setDate(lastDay - offset + (week + 1) * 7);\n        }\n\n        return date;\n    }\n\n    /**\n     * Get list of common timezones\n     * @returns {Array<{value: string, label: string, offset: string}>}\n     */\n    getCommonTimezones() {\n        const now = new Date();\n        const timezones = [\n            { value: 'America/New_York', label: 'Eastern Time (New York)', region: 'Americas' },\n            { value: 'America/Chicago', label: 'Central Time (Chicago)', region: 'Americas' },\n            { value: 'America/Denver', label: 'Mountain Time (Denver)', region: 'Americas' },\n            { value: 'America/Phoenix', label: 'Mountain Time - Arizona (Phoenix)', region: 'Americas' },\n            { value: 'America/Los_Angeles', label: 'Pacific Time (Los Angeles)', region: 'Americas' },\n            { value: 'America/Anchorage', label: 'Alaska Time (Anchorage)', region: 'Americas' },\n            { value: 'Pacific/Honolulu', label: 'Hawaii Time (Honolulu)', region: 'Pacific' },\n            { value: 'America/Toronto', label: 'Eastern Time (Toronto)', region: 'Americas' },\n            { value: 'America/Vancouver', label: 'Pacific Time (Vancouver)', region: 'Americas' },\n            { value: 'America/Mexico_City', label: 'Central Time (Mexico City)', region: 'Americas' },\n            { value: 'America/Sao_Paulo', label: 'Brasilia Time (SÃ£o Paulo)', region: 'Americas' },\n            { value: 'Europe/London', label: 'GMT/BST (London)', region: 'Europe' },\n            { value: 'Europe/Paris', label: 'Central European Time (Paris)', region: 'Europe' },\n            { value: 'Europe/Berlin', label: 'Central European Time (Berlin)', region: 'Europe' },\n            { value: 'Europe/Moscow', label: 'Moscow Time', region: 'Europe' },\n            { value: 'Asia/Dubai', label: 'Gulf Time (Dubai)', region: 'Asia' },\n            { value: 'Asia/Kolkata', label: 'India Time (Mumbai)', region: 'Asia' },\n            { value: 'Asia/Shanghai', label: 'China Time (Shanghai)', region: 'Asia' },\n            { value: 'Asia/Tokyo', label: 'Japan Time (Tokyo)', region: 'Asia' },\n            { value: 'Asia/Seoul', label: 'Korea Time (Seoul)', region: 'Asia' },\n            { value: 'Asia/Singapore', label: 'Singapore Time', region: 'Asia' },\n            { value: 'Australia/Sydney', label: 'Australian Eastern Time (Sydney)', region: 'Oceania' },\n            { value: 'Australia/Melbourne', label: 'Australian Eastern Time (Melbourne)', region: 'Oceania' },\n            { value: 'Pacific/Auckland', label: 'New Zealand Time (Auckland)', region: 'Oceania' },\n            { value: 'UTC', label: 'UTC', region: 'UTC' }\n        ];\n\n        // Add current offset to each timezone\n        return timezones.map(tz => {\n            const offset = this.getTimezoneOffset(now, tz.value);\n            const offsetHours = -offset / 60; // Convert to hours from UTC\n            const hours = Math.floor(Math.abs(offsetHours));\n            const minutes = Math.round(Math.abs(offsetHours % 1) * 60);\n            const sign = offsetHours >= 0 ? '+' : '-';\n            const offsetStr = `UTC${sign}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n\n            return {\n                ...tz,\n                offset: offsetStr,\n                offsetMinutes: -offset // Store in minutes for sorting\n            };\n        }).sort((a, b) => a.offsetMinutes - b.offsetMinutes);\n    }\n\n    /**\n     * Format date in specific timezone\n     * @param {Date} date - Date to format\n     * @param {string} timezone - Timezone for formatting\n     * @param {Object} options - Formatting options\n     * @returns {string} Formatted date string\n     */\n    formatInTimezone(date, timezone, options = {}) {\n        if (!date) return '';\n\n        const defaultOptions = {\n            year: 'numeric',\n            month: '2-digit',\n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            hour12: true,\n            timeZone: timezone\n        };\n\n        const formatOptions = { ...defaultOptions, ...options };\n\n        try {\n            return new Intl.DateTimeFormat('en-US', formatOptions).format(date);\n        } catch (e) {\n            // Fallback to basic formatting\n            const tzDate = this.fromUTC(this.toUTC(date, 'UTC'), timezone);\n            return tzDate.toLocaleString('en-US', options);\n        }\n    }\n\n    /**\n     * Get timezone from browser/system\n     * @returns {string} IANA timezone identifier\n     */\n    getSystemTimezone() {\n        if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {\n            try {\n                return Intl.DateTimeFormat().resolvedOptions().timeZone;\n            } catch (e) {\n                // Fallback\n            }\n        }\n\n        // Fallback based on offset\n        const offset = new Date().getTimezoneOffset();\n        const offsetHours = -offset / 60;\n\n        // Try to match offset to known timezone\n        for (const [tz, tzOffset] of Object.entries(this.timezoneOffsets)) {\n            if (tzOffset === offsetHours) {\n                return tz;\n            }\n        }\n\n        return 'UTC';\n    }\n\n    /**\n     * Parse timezone from string (handles abbreviations)\n     * @param {string} tzString - Timezone string\n     * @returns {string} IANA timezone identifier\n     */\n    parseTimezone(tzString) {\n        if (!tzString) return 'UTC';\n\n        // Check if it's already an IANA identifier\n        if (this.timezoneOffsets.hasOwnProperty(tzString)) {\n            return tzString;\n        }\n\n        // Check abbreviations\n        const upperTz = tzString.toUpperCase();\n        if (this.timezoneAbbreviations.hasOwnProperty(upperTz)) {\n            return this.timezoneAbbreviations[upperTz];\n        }\n\n        // Try to parse offset format (e.g., \"+05:30\", \"-08:00\")\n        const offsetMatch = tzString.match(/^([+-])(\\d{2}):?(\\d{2})$/);\n        if (offsetMatch) {\n            const sign = offsetMatch[1] === '+' ? 1 : -1;\n            const hours = parseInt(offsetMatch[2], 10);\n            const minutes = parseInt(offsetMatch[3], 10);\n            const totalOffset = sign * (hours + minutes / 60);\n\n            // Find matching timezone\n            for (const [tz, offset] of Object.entries(this.timezoneOffsets)) {\n                if (offset === totalOffset) {\n                    return tz;\n                }\n            }\n        }\n\n        return 'UTC';\n    }\n\n    /**\n     * Calculate timezone difference in hours\n     * @param {string} timezone1 - First timezone\n     * @param {string} timezone2 - Second timezone\n     * @param {Date} [date] - Date for DST calculation\n     * @returns {number} Hour difference\n     */\n    getTimezoneDifference(timezone1, timezone2, date = new Date()) {\n        const offset1 = this.getTimezoneOffset(date, timezone1);\n        const offset2 = this.getTimezoneOffset(date, timezone2);\n        return (offset2 - offset1) / 60;\n    }\n\n    /**\n     * Clear caches (useful when date changes significantly)\n     */\n    clearCache() {\n        this.offsetCache.clear();\n        this.dstCache.clear();\n    }\n}","/**\n * Event class - represents a calendar event with timezone support\n * Pure JavaScript, no DOM dependencies\n * Locker Service compatible\n */\n\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\nexport class Event {\n  /**\n   * Normalize event data\n   * @param {import('../../types.js').EventData} data - Raw event data\n   * @returns {import('../../types.js').EventData} Normalized event data\n   */\n  static normalize(data) {\n    const normalized = { ...data };\n\n    // Ensure dates are Date objects\n    if (normalized.start && !(normalized.start instanceof Date)) {\n      normalized.start = new Date(normalized.start);\n    }\n    if (normalized.end && !(normalized.end instanceof Date)) {\n      normalized.end = new Date(normalized.end);\n    }\n\n    // If no end date, set it to start date\n    if (!normalized.end) {\n      normalized.end = normalized.start ? new Date(normalized.start) : null;\n    }\n\n    // For all-day events, normalize times to midnight\n    if (normalized.allDay && normalized.start) {\n      normalized.start.setHours(0, 0, 0, 0);\n      if (normalized.end) {\n        normalized.end.setHours(23, 59, 59, 999);\n      }\n    }\n\n    // Normalize string fields\n    normalized.id = String(normalized.id || '').trim();\n    normalized.title = String(normalized.title || '').trim();\n    normalized.description = String(normalized.description || '').trim();\n    normalized.location = String(normalized.location || '').trim();\n\n    // Normalize arrays\n    normalized.attendees = Array.isArray(normalized.attendees) ? normalized.attendees : [];\n    normalized.reminders = Array.isArray(normalized.reminders) ? normalized.reminders : [];\n    normalized.categories = Array.isArray(normalized.categories) ? normalized.categories : [];\n    normalized.attachments = Array.isArray(normalized.attachments) ? normalized.attachments : [];\n\n    // Normalize status and visibility\n    const validStatuses = ['confirmed', 'tentative', 'cancelled'];\n    if (!validStatuses.includes(normalized.status)) {\n      normalized.status = 'confirmed';\n    }\n\n    const validVisibilities = ['public', 'private', 'confidential'];\n    if (!validVisibilities.includes(normalized.visibility)) {\n      normalized.visibility = 'public';\n    }\n\n    // Normalize colors\n    if (normalized.color && !normalized.backgroundColor) {\n      normalized.backgroundColor = normalized.color;\n    }\n    if (normalized.color && !normalized.borderColor) {\n      normalized.borderColor = normalized.color;\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Validate event data\n   * @param {import('../../types.js').EventData} data - Normalized event data\n   * @throws {Error} If validation fails\n   */\n  static validate(data) {\n    // Required fields\n    if (!data.id) {\n      throw new Error('Event must have an id');\n    }\n    if (!data.title) {\n      throw new Error('Event must have a title');\n    }\n    if (!data.start) {\n      throw new Error('Event must have a start date');\n    }\n\n    // Validate dates\n    if (!(data.start instanceof Date) || isNaN(data.start.getTime())) {\n      throw new Error('Invalid start date');\n    }\n    if (data.end && (!(data.end instanceof Date) || isNaN(data.end.getTime()))) {\n      throw new Error('Invalid end date');\n    }\n\n    // Validate date order\n    if (data.end && data.start && data.end < data.start) {\n      throw new Error('Event end time cannot be before start time');\n    }\n\n    // Validate recurrence\n    if (data.recurring && !data.recurrenceRule) {\n      throw new Error('Recurring events must have a recurrence rule');\n    }\n\n    // Validate attendees\n    if (data.attendees && data.attendees.length > 0) {\n      data.attendees.forEach((attendee, index) => {\n        if (!attendee.email || !attendee.name) {\n          throw new Error(`Attendee at index ${index} must have email and name`);\n        }\n        // Validate email format\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(attendee.email)) {\n          throw new Error(`Invalid email for attendee: ${attendee.email}`);\n        }\n      });\n    }\n\n    // Validate reminders\n    if (data.reminders && data.reminders.length > 0) {\n      data.reminders.forEach((reminder, index) => {\n        if (!reminder.method || reminder.minutesBefore == null) {\n          throw new Error(`Reminder at index ${index} must have method and minutesBefore`);\n        }\n        if (reminder.minutesBefore < 0) {\n          throw new Error('Reminder minutesBefore must be non-negative');\n        }\n      });\n    }\n\n    // Validate timezone if provided\n    if (data.timeZone) {\n      try {\n        // Test if timezone is valid by trying to use it\n        new Intl.DateTimeFormat('en-US', { timeZone: data.timeZone });\n      } catch (e) {\n        throw new Error(`Invalid timezone: ${data.timeZone}`);\n      }\n    }\n  }\n\n  /**\n   * Create a new Event instance\n   * @param {import('../../types.js').EventData} eventData - Event data object\n   * @throws {Error} If required fields are missing or invalid\n   */\n  constructor({\n    id,\n    title,\n    start,\n    end,\n    allDay = false,\n    description = '',\n    location = '',\n    color = null,\n    backgroundColor = null,\n    borderColor = null,\n    textColor = null,\n    recurring = false,\n    recurrenceRule = null,\n    timeZone = null,\n    endTimeZone = null,\n    status = 'confirmed',\n    visibility = 'public',\n    organizer = null,\n    attendees = [],\n    reminders = [],\n    categories = [],\n    attachments = [],\n    conferenceData = null,\n    metadata = {}\n  }) {\n    // Normalize and validate input\n    const normalized = Event.normalize({\n      id,\n      title,\n      start,\n      end,\n      allDay,\n      description,\n      location,\n      color,\n      backgroundColor,\n      borderColor,\n      textColor,\n      recurring,\n      recurrenceRule,\n      timeZone,\n      endTimeZone,\n      status,\n      visibility,\n      organizer,\n      attendees,\n      reminders,\n      categories,\n      attachments,\n      conferenceData,\n      metadata\n    });\n\n    // Validate normalized data\n    Event.validate(normalized);\n\n    this.id = normalized.id;\n    this.title = normalized.title;\n\n    // Initialize timezone manager\n    this._timezoneManager = new TimezoneManager();\n\n    // Timezone handling\n    // Store the timezone the event was created in (wall-clock time)\n    this.timeZone = normalized.timeZone || this._timezoneManager.getSystemTimezone();\n    this.endTimeZone = normalized.endTimeZone || this.timeZone; // Different end timezone for flights etc.\n\n    // Store dates as provided (wall-clock time in event timezone)\n    this.start = normalized.start;\n    this.end = normalized.end;\n\n    // Store UTC versions for efficient querying and comparison\n    this.startUTC = this._timezoneManager.toUTC(this.start, this.timeZone);\n    this.endUTC = this._timezoneManager.toUTC(this.end, this.endTimeZone);\n\n    this.allDay = normalized.allDay;\n    this.description = normalized.description;\n    this.location = normalized.location;\n\n    // Styling\n    this.color = normalized.color;\n    this.backgroundColor = normalized.backgroundColor;\n    this.borderColor = normalized.borderColor;\n    this.textColor = normalized.textColor;\n\n    // Recurrence\n    this.recurring = normalized.recurring;\n    this.recurrenceRule = normalized.recurrenceRule;\n\n    // Store original timezone from system if not provided\n    this._originalTimeZone = normalized.timeZone || null;\n\n    // Event status and visibility\n    this.status = normalized.status;\n    this.visibility = normalized.visibility;\n\n    // People\n    this.organizer = normalized.organizer;\n    this.attendees = [...normalized.attendees];\n\n    // Reminders\n    this.reminders = [...normalized.reminders];\n\n    // Categories/Tags\n    this.categories = [...normalized.categories];\n\n    // Attachments\n    this.attachments = [...normalized.attachments];\n\n    // Conference/Virtual meeting\n    this.conferenceData = normalized.conferenceData;\n\n    // Custom metadata for extensibility\n    this.metadata = { ...normalized.metadata };\n\n    // Computed properties cache\n    this._cache = {};\n\n    // Validate complex properties\n    this._validateAttendees();\n    this._validateReminders();\n  }\n\n  /**\n   * Get event duration in milliseconds\n   * @returns {number} Duration in milliseconds\n   */\n  get duration() {\n    if (!this._cache.duration) {\n      // Use UTC times for accurate duration calculation\n      this._cache.duration = this.endUTC.getTime() - this.startUTC.getTime();\n    }\n    return this._cache.duration;\n  }\n\n  /**\n   * Get start date in a specific timezone\n   * @param {string} timezone - Target timezone\n   * @returns {Date} Start date in specified timezone\n   */\n  getStartInTimezone(timezone) {\n    if (timezone === this.timeZone) {\n      return new Date(this.start);\n    }\n    return this._timezoneManager.fromUTC(this.startUTC, timezone);\n  }\n\n  /**\n   * Get end date in a specific timezone\n   * @param {string} timezone - Target timezone\n   * @returns {Date} End date in specified timezone\n   */\n  getEndInTimezone(timezone) {\n    if (timezone === this.endTimeZone) {\n      return new Date(this.end);\n    }\n    return this._timezoneManager.fromUTC(this.endUTC, timezone);\n  }\n\n  /**\n   * Update event times preserving the timezone\n   * @param {Date} start - New start date\n   * @param {Date} end - New end date\n   * @param {string} [timezone] - Timezone for the new dates\n   */\n  updateTimes(start, end, timezone) {\n    const tz = timezone || this.timeZone;\n\n    this.start = start instanceof Date ? start : new Date(start);\n    this.end = end instanceof Date ? end : new Date(end);\n\n    if (timezone) {\n      this.timeZone = timezone;\n      this.endTimeZone = timezone;\n    }\n\n    // Update UTC versions\n    this.startUTC = this._timezoneManager.toUTC(this.start, this.timeZone);\n    this.endUTC = this._timezoneManager.toUTC(this.end, this.endTimeZone);\n\n    // Clear cache\n    this._cache = {};\n\n    // Validate\n    if (this.endUTC < this.startUTC) {\n      throw new Error('Event end time cannot be before start time');\n    }\n  }\n\n  /**\n   * Get event duration in minutes\n   * @returns {number} Duration in minutes\n   */\n  get durationMinutes() {\n    return Math.floor(this.duration / (1000 * 60));\n  }\n\n  /**\n   * Get event duration in hours\n   * @returns {number} Duration in hours\n   */\n  get durationHours() {\n    return this.duration / (1000 * 60 * 60);\n  }\n\n  /**\n   * Check if this is a multi-day event\n   * @returns {boolean} True if event spans multiple days\n   */\n  get isMultiDay() {\n    if (!this._cache.hasOwnProperty('isMultiDay')) {\n      const startDay = this.start.toDateString();\n      const endDay = this.end.toDateString();\n      this._cache.isMultiDay = startDay !== endDay;\n    }\n    return this._cache.isMultiDay;\n  }\n\n  /**\n   * Check if event is recurring\n   * @returns {boolean} True if event is recurring\n   */\n  isRecurring() {\n    return this.recurring && this.recurrenceRule !== null;\n  }\n\n  /**\n   * Check if event occurs on a specific date\n   * @param {Date|string} date - The date to check\n   * @returns {boolean} True if event occurs on the given date\n   */\n  occursOn(date) {\n    if (!(date instanceof Date)) {\n      date = new Date(date);\n    }\n\n    const dateString = date.toDateString();\n    const startString = this.start.toDateString();\n    const endString = this.end.toDateString();\n\n    // For all-day events, check if date falls within range\n    if (this.allDay) {\n      return date >= new Date(startString) && date <= new Date(endString);\n    }\n\n    // For timed events, check if any part of the event occurs on this date\n    if (this.isMultiDay) {\n      // Multi-day event: check if date is within range\n      const dayStart = new Date(dateString);\n      const dayEnd = new Date(dateString);\n      dayEnd.setHours(23, 59, 59, 999);\n\n      return this.start <= dayEnd && this.end >= dayStart;\n    } else {\n      // Single day event: check if it's on the same day\n      return startString === dateString;\n    }\n  }\n\n  /**\n   * Check if this event overlaps with another event\n   * @param {Event|{start: Date, end: Date}} otherEvent - The other event or time range to check\n   * @returns {boolean} True if events overlap\n   * @throws {Error} If otherEvent is not an Event instance or doesn't have start/end\n   */\n  overlaps(otherEvent) {\n    if (otherEvent instanceof Event) {\n      // Events don't overlap if one ends before the other starts\n      return !(this.end <= otherEvent.start || this.start >= otherEvent.end);\n    } else if (otherEvent && otherEvent.start && otherEvent.end) {\n      // Allow checking against time ranges\n      return !(this.end <= otherEvent.start || this.start >= otherEvent.end);\n    } else {\n      throw new Error('Parameter must be an Event instance or have start/end properties');\n    }\n  }\n\n  /**\n   * Check if event contains a specific datetime\n   * @param {Date|string} datetime - The datetime to check\n   * @returns {boolean} True if the datetime falls within the event\n   */\n  contains(datetime) {\n    if (!(datetime instanceof Date)) {\n      datetime = new Date(datetime);\n    }\n    return datetime >= this.start && datetime <= this.end;\n  }\n\n  /**\n   * Clone the event with optional updates\n   * @param {Partial<import('../../types.js').EventData>} [updates={}] - Properties to update in the clone\n   * @returns {Event} New Event instance with updated properties\n   */\n  clone(updates = {}) {\n    return new Event({\n      id: this.id,\n      title: this.title,\n      start: new Date(this.start),\n      end: new Date(this.end),\n      allDay: this.allDay,\n      description: this.description,\n      location: this.location,\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      borderColor: this.borderColor,\n      textColor: this.textColor,\n      recurring: this.recurring,\n      recurrenceRule: this.recurrenceRule,\n      timeZone: this.timeZone,\n      status: this.status,\n      visibility: this.visibility,\n      organizer: this.organizer ? { ...this.organizer } : null,\n      attendees: this.attendees.map(a => ({ ...a })),\n      reminders: this.reminders.map(r => ({ ...r })),\n      categories: [...this.categories],\n      attachments: this.attachments.map(a => ({ ...a })),\n      conferenceData: this.conferenceData ? { ...this.conferenceData } : null,\n      metadata: { ...this.metadata },\n      ...updates\n    });\n  }\n\n  /**\n   * Convert event to plain object\n   * @returns {import('../../types.js').EventData} Plain object representation of the event\n   */\n  toObject() {\n    return {\n      id: this.id,\n      title: this.title,\n      start: this.start.toISOString(),\n      end: this.end.toISOString(),\n      allDay: this.allDay,\n      description: this.description,\n      location: this.location,\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      borderColor: this.borderColor,\n      textColor: this.textColor,\n      recurring: this.recurring,\n      recurrenceRule: this.recurrenceRule,\n      timeZone: this.timeZone,\n      status: this.status,\n      visibility: this.visibility,\n      organizer: this.organizer,\n      attendees: this.attendees,\n      reminders: this.reminders,\n      categories: this.categories,\n      attachments: this.attachments,\n      conferenceData: this.conferenceData,\n      metadata: { ...this.metadata }\n    };\n  }\n\n  /**\n   * Create Event from plain object\n   * @param {import('../../types.js').EventData} obj - Plain object with event properties\n   * @returns {Event} New Event instance\n   */\n  static fromObject(obj) {\n    return new Event(obj);\n  }\n\n  /**\n   * Compare events for equality\n   * @param {Event} other - The other event\n   * @returns {boolean} True if events are equal\n   */\n  equals(other) {\n    if (!(other instanceof Event)) return false;\n\n    return (\n      this.id === other.id &&\n      this.title === other.title &&\n      this.start.getTime() === other.start.getTime() &&\n      this.end.getTime() === other.end.getTime() &&\n      this.allDay === other.allDay &&\n      this.description === other.description &&\n      this.location === other.location &&\n      this.recurring === other.recurring &&\n      this.recurrenceRule === other.recurrenceRule &&\n      this.status === other.status\n    );\n  }\n\n  // ============ Attendee Management Methods ============\n\n  /**\n   * Add an attendee to the event\n   * @param {import('../../types.js').Attendee} attendee - Attendee to add\n   * @returns {boolean} True if attendee was added, false if already exists\n   */\n  addAttendee(attendee) {\n    if (!attendee || !attendee.email) {\n      throw new Error('Attendee must have an email');\n    }\n\n    // Check if attendee already exists\n    if (this.hasAttendee(attendee.email)) {\n      return false;\n    }\n\n    // Generate ID if not provided\n    if (!attendee.id) {\n      attendee.id = `attendee_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    // Set defaults\n    attendee.responseStatus = attendee.responseStatus || 'needs-action';\n    attendee.role = attendee.role || 'required';\n\n    this.attendees.push(attendee);\n    return true;\n  }\n\n  /**\n   * Remove an attendee from the event\n   * @param {string} emailOrId - Email or ID of the attendee to remove\n   * @returns {boolean} True if attendee was removed\n   */\n  removeAttendee(emailOrId) {\n    const index = this.attendees.findIndex(\n      a => a.email === emailOrId || a.id === emailOrId\n    );\n\n    if (index !== -1) {\n      this.attendees.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Update an attendee's response status\n   * @param {string} email - Attendee's email\n   * @param {import('../../types.js').AttendeeResponseStatus} responseStatus - New response status\n   * @returns {boolean} True if attendee was updated\n   */\n  updateAttendeeResponse(email, responseStatus) {\n    const attendee = this.getAttendee(email);\n    if (attendee) {\n      attendee.responseStatus = responseStatus;\n      attendee.responseTime = new Date();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get an attendee by email\n   * @param {string} email - Attendee's email\n   * @returns {import('../../types.js').Attendee|null} The attendee or null\n   */\n  getAttendee(email) {\n    return this.attendees.find(a => a.email === email) || null;\n  }\n\n  /**\n   * Check if an attendee exists\n   * @param {string} email - Attendee's email\n   * @returns {boolean} True if attendee exists\n   */\n  hasAttendee(email) {\n    return this.attendees.some(a => a.email === email);\n  }\n\n  /**\n   * Get attendees by response status\n   * @param {import('../../types.js').AttendeeResponseStatus} status - Response status to filter by\n   * @returns {import('../../types.js').Attendee[]} Filtered attendees\n   */\n  getAttendeesByStatus(status) {\n    return this.attendees.filter(a => a.responseStatus === status);\n  }\n\n  /**\n   * Get count of attendees by response status\n   * @returns {Object.<string, number>} Count by status\n   */\n  getAttendeeCounts() {\n    return this.attendees.reduce((counts, attendee) => {\n      const status = attendee.responseStatus || 'needs-action';\n      counts[status] = (counts[status] || 0) + 1;\n      return counts;\n    }, {});\n  }\n\n  // ============ Reminder Management Methods ============\n\n  /**\n   * Add a reminder to the event\n   * @param {import('../../types.js').Reminder} reminder - Reminder to add\n   * @returns {boolean} True if reminder was added\n   */\n  addReminder(reminder) {\n    if (!reminder || typeof reminder.minutesBefore !== 'number') {\n      throw new Error('Reminder must have minutesBefore property');\n    }\n\n    // Generate ID if not provided\n    if (!reminder.id) {\n      reminder.id = `reminder_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    // Set defaults\n    reminder.method = reminder.method || 'popup';\n    reminder.enabled = reminder.enabled !== false;\n\n    // Check for duplicate\n    const duplicate = this.reminders.some(\n      r => r.method === reminder.method && r.minutesBefore === reminder.minutesBefore\n    );\n\n    if (duplicate) {\n      return false;\n    }\n\n    this.reminders.push(reminder);\n    return true;\n  }\n\n  /**\n   * Remove a reminder from the event\n   * @param {string} reminderId - ID of the reminder to remove\n   * @returns {boolean} True if reminder was removed\n   */\n  removeReminder(reminderId) {\n    const index = this.reminders.findIndex(r => r.id === reminderId);\n    if (index !== -1) {\n      this.reminders.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get active reminders\n   * @returns {import('../../types.js').Reminder[]} Active reminders\n   */\n  getActiveReminders() {\n    return this.reminders.filter(r => r.enabled !== false);\n  }\n\n  /**\n   * Get reminder trigger times\n   * @returns {Date[]} Array of dates when reminders should trigger\n   */\n  getReminderTriggerTimes() {\n    return this.getActiveReminders().map(reminder => {\n      const triggerTime = new Date(this.start);\n      triggerTime.setMinutes(triggerTime.getMinutes() - reminder.minutesBefore);\n      return triggerTime;\n    });\n  }\n\n  // ============ Category Management Methods ============\n\n  /**\n   * Add a category to the event\n   * @param {string} category - Category to add\n   * @returns {boolean} True if category was added\n   */\n  addCategory(category) {\n    if (!category || typeof category !== 'string') {\n      throw new Error('Category must be a non-empty string');\n    }\n\n    const normalizedCategory = category.trim().toLowerCase();\n    if (!this.hasCategory(normalizedCategory)) {\n      this.categories.push(normalizedCategory);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Remove a category from the event\n   * @param {string} category - Category to remove\n   * @returns {boolean} True if category was removed\n   */\n  removeCategory(category) {\n    const normalizedCategory = category.trim().toLowerCase();\n    const index = this.categories.findIndex(\n      c => c.toLowerCase() === normalizedCategory\n    );\n\n    if (index !== -1) {\n      this.categories.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Check if event has a specific category\n   * @param {string} category - Category to check\n   * @returns {boolean} True if event has the category\n   */\n  hasCategory(category) {\n    const normalizedCategory = category.trim().toLowerCase();\n    return this.categories.some(c => c.toLowerCase() === normalizedCategory);\n  }\n\n  /**\n   * Check if event has any of the specified categories\n   * @param {string[]} categories - Categories to check\n   * @returns {boolean} True if event has any of the categories\n   */\n  hasAnyCategory(categories) {\n    return categories.some(category => this.hasCategory(category));\n  }\n\n  /**\n   * Check if event has all of the specified categories\n   * @param {string[]} categories - Categories to check\n   * @returns {boolean} True if event has all of the categories\n   */\n  hasAllCategories(categories) {\n    return categories.every(category => this.hasCategory(category));\n  }\n\n  // ============ Validation Methods ============\n\n  /**\n   * Validate attendees\n   * @private\n   * @throws {Error} If attendees are invalid\n   */\n  _validateAttendees() {\n    for (const attendee of this.attendees) {\n      if (!attendee.email) {\n        throw new Error('All attendees must have an email address');\n      }\n      if (!attendee.name) {\n        attendee.name = attendee.email; // Use email as fallback name\n      }\n      if (!this._isValidEmail(attendee.email)) {\n        throw new Error(`Invalid attendee email: ${attendee.email}`);\n      }\n    }\n  }\n\n  /**\n   * Validate reminders\n   * @private\n   * @throws {Error} If reminders are invalid\n   */\n  _validateReminders() {\n    for (const reminder of this.reminders) {\n      if (typeof reminder.minutesBefore !== 'number' || reminder.minutesBefore < 0) {\n        throw new Error('Reminder minutesBefore must be a positive number');\n      }\n\n      const validMethods = ['email', 'popup', 'sms'];\n      if (!validMethods.includes(reminder.method)) {\n        throw new Error(`Invalid reminder method: ${reminder.method}`);\n      }\n    }\n  }\n\n  /**\n   * Validate email address\n   * @private\n   * @param {string} email - Email to validate\n   * @returns {boolean} True if email is valid\n   */\n  _isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // ============ Enhanced Getters ============\n\n  /**\n   * Check if the event is cancelled\n   * @returns {boolean} True if event is cancelled\n   */\n  get isCancelled() {\n    return this.status === 'cancelled';\n  }\n\n  /**\n   * Check if the event is tentative\n   * @returns {boolean} True if event is tentative\n   */\n  get isTentative() {\n    return this.status === 'tentative';\n  }\n\n  /**\n   * Check if the event is confirmed\n   * @returns {boolean} True if event is confirmed\n   */\n  get isConfirmed() {\n    return this.status === 'confirmed';\n  }\n\n  /**\n   * Check if the event is private\n   * @returns {boolean} True if event is private\n   */\n  get isPrivate() {\n    return this.visibility === 'private';\n  }\n\n  /**\n   * Check if the event is public\n   * @returns {boolean} True if event is public\n   */\n  get isPublic() {\n    return this.visibility === 'public';\n  }\n\n  /**\n   * Check if the event has attendees\n   * @returns {boolean} True if event has attendees\n   */\n  get hasAttendees() {\n    return this.attendees.length > 0;\n  }\n\n  /**\n   * Check if the event has reminders\n   * @returns {boolean} True if event has reminders\n   */\n  get hasReminders() {\n    return this.reminders.length > 0;\n  }\n\n  /**\n   * Check if the event is a meeting (has attendees or conference data)\n   * @returns {boolean} True if event is a meeting\n   */\n  get isMeeting() {\n    return this.hasAttendees || this.conferenceData !== null;\n  }\n\n  /**\n   * Check if the event is virtual (has conference data)\n   * @returns {boolean} True if event is virtual\n   */\n  get isVirtual() {\n    return this.conferenceData !== null;\n  }\n}","/**\n * DateUtils - Date manipulation utilities\n * Pure functions, no external dependencies\n * Locker Service compatible\n */\nexport class DateUtils {\n  /**\n   * Get the start of a day\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static startOfDay(date) {\n    const result = new Date(date);\n    result.setHours(0, 0, 0, 0);\n    return result;\n  }\n\n  /**\n   * Get the end of a day\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static endOfDay(date) {\n    const result = new Date(date);\n    result.setHours(23, 59, 59, 999);\n    return result;\n  }\n\n  /**\n   * Get the start of a week\n   * @param {Date} date - The date\n   * @param {number} [weekStartsOn=0] - 0 = Sunday, 1 = Monday, etc.\n   * @returns {Date} Start of the week\n   */\n  static startOfWeek(date, weekStartsOn = 0) {\n    const result = new Date(date);\n    const day = result.getDay();\n    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;\n\n    // Use setTime to handle month/year boundaries correctly\n    result.setTime(result.getTime() - (diff * 24 * 60 * 60 * 1000));\n    result.setHours(0, 0, 0, 0);\n    return result;\n  }\n\n  /**\n   * Get the end of a week\n   * @param {Date} date - The date\n   * @param {number} weekStartsOn - 0 = Sunday, 1 = Monday, etc.\n   * @returns {Date}\n   */\n  static endOfWeek(date, weekStartsOn = 0) {\n    const result = DateUtils.startOfWeek(date, weekStartsOn);\n    // Use setTime to handle month/year boundaries correctly\n    result.setTime(result.getTime() + (6 * 24 * 60 * 60 * 1000));\n    result.setHours(23, 59, 59, 999);\n    return result;\n  }\n\n  /**\n   * Get the start of a month\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static startOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth(), 1, 0, 0, 0, 0);\n  }\n\n  /**\n   * Get the end of a month\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static endOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0, 23, 59, 59, 999);\n  }\n\n  /**\n   * Get the start of a year\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static startOfYear(date) {\n    return new Date(date.getFullYear(), 0, 1, 0, 0, 0, 0);\n  }\n\n  /**\n   * Get the end of a year\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static endOfYear(date) {\n    return new Date(date.getFullYear(), 11, 31, 23, 59, 59, 999);\n  }\n\n  /**\n   * Add days to a date\n   * @param {Date} date - The date\n   * @param {number} days - Number of days to add (can be negative)\n   * @returns {Date}\n   */\n  static addDays(date, days) {\n    const result = new Date(date);\n    // Use setTime to handle month/year boundaries correctly\n    result.setTime(result.getTime() + (days * 24 * 60 * 60 * 1000));\n    return result;\n  }\n\n  /**\n   * Add weeks to a date\n   * @param {Date} date - The date\n   * @param {number} weeks - Number of weeks to add\n   * @returns {Date}\n   */\n  static addWeeks(date, weeks) {\n    return DateUtils.addDays(date, weeks * 7);\n  }\n\n  /**\n   * Add months to a date\n   * @param {Date} date - The date\n   * @param {number} months - Number of months to add\n   * @returns {Date}\n   */\n  static addMonths(date, months) {\n    const result = new Date(date);\n    const dayOfMonth = result.getDate();\n    result.setMonth(result.getMonth() + months);\n\n    // Handle edge case where day doesn't exist in new month\n    if (result.getDate() !== dayOfMonth) {\n      result.setDate(0); // Go to last day of previous month\n    }\n\n    return result;\n  }\n\n  /**\n   * Add years to a date\n   * @param {Date} date - The date\n   * @param {number} years - Number of years to add\n   * @returns {Date}\n   */\n  static addYears(date, years) {\n    const result = new Date(date);\n    result.setFullYear(result.getFullYear() + years);\n    return result;\n  }\n\n  /**\n   * Get a consistent UTC date string for indexing (YYYY-MM-DD format)\n   * @param {Date} date - The date\n   * @returns {string} UTC date string\n   */\n  static getUTCDateString(date) {\n    const year = date.getUTCFullYear();\n    const month = String(date.getUTCMonth() + 1).padStart(2, '0');\n    const day = String(date.getUTCDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n  }\n\n  /**\n   * Get a consistent local date string for indexing (YYYY-MM-DD format)\n   * @param {Date} date - The date\n   * @returns {string} Local date string\n   */\n  static getLocalDateString(date) {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const day = String(date.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n  }\n\n  /**\n   * Check if a date is today\n   * @param {Date} date - The date to check\n   * @returns {boolean}\n   */\n  static isToday(date) {\n    const today = new Date();\n    return date.toDateString() === today.toDateString();\n  }\n\n  /**\n   * Check if a date is in the past\n   * @param {Date} date - The date to check\n   * @returns {boolean}\n   */\n  static isPast(date) {\n    return date < new Date();\n  }\n\n  /**\n   * Check if a date is in the future\n   * @param {Date} date - The date to check\n   * @returns {boolean}\n   */\n  static isFuture(date) {\n    return date > new Date();\n  }\n\n  /**\n   * Check if two dates are on the same day\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {boolean}\n   */\n  static isSameDay(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear() &&\n           date1.getMonth() === date2.getMonth() &&\n           date1.getDate() === date2.getDate();\n  }\n\n  /**\n   * Check if two dates are in the same week\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @param {number} weekStartsOn - 0 = Sunday, 1 = Monday, etc.\n   * @returns {boolean}\n   */\n  static isSameWeek(date1, date2, weekStartsOn = 0) {\n    const week1Start = DateUtils.startOfWeek(date1, weekStartsOn);\n    const week2Start = DateUtils.startOfWeek(date2, weekStartsOn);\n    return week1Start.toDateString() === week2Start.toDateString();\n  }\n\n  /**\n   * Check if two dates are in the same month\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {boolean}\n   */\n  static isSameMonth(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear() &&\n           date1.getMonth() === date2.getMonth();\n  }\n\n  /**\n   * Check if two dates are in the same year\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {boolean}\n   */\n  static isSameYear(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear();\n  }\n\n  /**\n   * Get the difference in days between two dates\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {number}\n   */\n  static differenceInDays(date1, date2) {\n    const diff = date1.getTime() - date2.getTime();\n    return Math.floor(diff / (1000 * 60 * 60 * 24));\n  }\n\n  /**\n   * Get the difference in weeks between two dates\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {number}\n   */\n  static differenceInWeeks(date1, date2) {\n    return Math.floor(DateUtils.differenceInDays(date1, date2) / 7);\n  }\n\n  /**\n   * Get the difference in months between two dates\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {number}\n   */\n  static differenceInMonths(date1, date2) {\n    const yearDiff = date1.getFullYear() - date2.getFullYear();\n    const monthDiff = date1.getMonth() - date2.getMonth();\n    return yearDiff * 12 + monthDiff;\n  }\n\n  /**\n   * Get the week number of a date\n   * @param {Date} date - The date\n   * @returns {number}\n   */\n  static getWeekNumber(date) {\n    const firstDayOfYear = new Date(date.getFullYear(), 0, 1);\n    const pastDaysOfYear = (date - firstDayOfYear) / 86400000;\n    return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);\n  }\n\n  /**\n   * Get the day of week for a date\n   * @param {Date} date - The date\n   * @param {number} weekStartsOn - 0 = Sunday, 1 = Monday, etc.\n   * @returns {number} 0-6 where 0 is the first day of the week\n   */\n  static getDayOfWeek(date, weekStartsOn = 0) {\n    const day = date.getDay();\n    return (day - weekStartsOn + 7) % 7;\n  }\n\n  /**\n   * Get days in a month\n   * @param {Date} date - Any date in the month\n   * @returns {number}\n   */\n  static getDaysInMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n  }\n\n  /**\n   * Format a date using Intl.DateTimeFormat\n   * @param {Date} date - The date to format\n   * @param {string} locale - The locale\n   * @param {Object} options - Intl.DateTimeFormat options\n   * @returns {string}\n   */\n  static format(date, locale = 'en-US', options = {}) {\n    return new Intl.DateTimeFormat(locale, options).format(date);\n  }\n\n  /**\n   * Get month name\n   * @param {Date} date - The date\n   * @param {string} locale - The locale\n   * @param {string} format - 'long', 'short', or 'narrow'\n   * @returns {string}\n   */\n  static getMonthName(date, locale = 'en-US', format = 'long') {\n    return DateUtils.format(date, locale, { month: format });\n  }\n\n  /**\n   * Get day name\n   * @param {Date} date - The date\n   * @param {string} locale - The locale\n   * @param {string} format - 'long', 'short', or 'narrow'\n   * @returns {string}\n   */\n  static getDayName(date, locale = 'en-US', format = 'long') {\n    return DateUtils.format(date, locale, { weekday: format });\n  }\n\n  /**\n   * Format time\n   * @param {Date} date - The date\n   * @param {string} locale - The locale\n   * @param {boolean} use24Hour - Use 24-hour format\n   * @returns {string}\n   */\n  static formatTime(date, locale = 'en-US', use24Hour = false) {\n    return DateUtils.format(date, locale, {\n      hour: 'numeric',\n      minute: '2-digit',\n      hour12: !use24Hour\n    });\n  }\n\n  /**\n   * Parse a time string (HH:MM) to hours and minutes\n   * @param {string} timeString - Time string like \"09:30\"\n   * @returns {{hours: number, minutes: number}}\n   */\n  static parseTime(timeString) {\n    const [hours, minutes] = timeString.split(':').map(Number);\n    return { hours, minutes };\n  }\n\n  /**\n   * Set time on a date\n   * @param {Date} date - The date\n   * @param {string} timeString - Time string like \"09:30\"\n   * @returns {Date}\n   */\n  static setTime(date, timeString) {\n    const result = new Date(date);\n    const { hours, minutes } = DateUtils.parseTime(timeString);\n    result.setHours(hours, minutes, 0, 0);\n    return result;\n  }\n\n  /**\n   * Check if a year is a leap year\n   * @param {number} year - The year\n   * @returns {boolean}\n   */\n  static isLeapYear(year) {\n    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n  }\n\n  /**\n   * Get an array of dates between start and end\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @returns {Date[]}\n   */\n  static getDateRange(start, end) {\n    const dates = [];\n    const current = new Date(start);\n    const endTime = end.getTime();\n\n    while (current.getTime() <= endTime) {\n      dates.push(new Date(current));\n      // Use setTime to handle month/year boundaries correctly\n      current.setTime(current.getTime() + (24 * 60 * 60 * 1000));\n    }\n\n    return dates;\n  }\n\n  /**\n   * Clone a date\n   * @param {Date} date - The date to clone\n   * @returns {Date}\n   */\n  static clone(date) {\n    return new Date(date);\n  }\n\n  /**\n   * Validate if a value is a valid date\n   * @param {*} value - Value to check\n   * @returns {boolean}\n   */\n  static isValidDate(value) {\n    return value instanceof Date && !isNaN(value.getTime());\n  }\n\n  /**\n   * Convert a date to a specific timezone\n   * @param {Date} date - The date to convert\n   * @param {string} timeZone - IANA timezone string (e.g., 'America/New_York')\n   * @returns {Date} - Date object adjusted for timezone\n   */\n  static toTimeZone(date, timeZone) {\n    // Get the date string in the target timezone\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      hour12: false\n    });\n\n    const parts = formatter.formatToParts(date);\n    const dateObj = {};\n    parts.forEach(part => {\n      if (part.type !== 'literal') {\n        dateObj[part.type] = part.value;\n      }\n    });\n\n    // Create new date in the target timezone\n    return new Date(\n      `${dateObj.year}-${dateObj.month}-${dateObj.day}T${dateObj.hour}:${dateObj.minute}:${dateObj.second}`\n    );\n  }\n\n  /**\n   * Get timezone offset in minutes for a date\n   * @param {Date} date - The date\n   * @param {string} timeZone - IANA timezone string\n   * @returns {number} - Offset in minutes\n   */\n  static getTimezoneOffset(date, timeZone) {\n    const utcDate = new Date(date.toLocaleString('en-US', { timeZone: 'UTC' }));\n    const tzDate = new Date(date.toLocaleString('en-US', { timeZone }));\n    return (utcDate.getTime() - tzDate.getTime()) / 60000;\n  }\n\n  /**\n   * Check if DST is in effect for a date in a timezone\n   * @param {Date} date - The date to check\n   * @param {string} timeZone - IANA timezone string\n   * @returns {boolean}\n   */\n  static isDST(date, timeZone) {\n    const jan = new Date(date.getFullYear(), 0, 1);\n    const jul = new Date(date.getFullYear(), 6, 1);\n    const janOffset = DateUtils.getTimezoneOffset(jan, timeZone);\n    const julOffset = DateUtils.getTimezoneOffset(jul, timeZone);\n    const currentOffset = DateUtils.getTimezoneOffset(date, timeZone);\n\n    return Math.max(janOffset, julOffset) === currentOffset;\n  }\n\n  /**\n   * Add time accounting for DST transitions\n   * @param {Date} date - The date\n   * @param {number} hours - Hours to add\n   * @param {string} timeZone - IANA timezone string\n   * @returns {Date}\n   */\n  static addHoursWithDST(date, hours, timeZone) {\n    const result = new Date(date);\n    const originalOffset = DateUtils.getTimezoneOffset(date, timeZone);\n\n    // Add hours\n    result.setTime(result.getTime() + (hours * 60 * 60 * 1000));\n\n    // Check if DST transition occurred\n    const newOffset = DateUtils.getTimezoneOffset(result, timeZone);\n    if (originalOffset !== newOffset) {\n      // Adjust for DST change\n      const dstAdjustment = (newOffset - originalOffset) * 60000;\n      result.setTime(result.getTime() + dstAdjustment);\n    }\n\n    return result;\n  }\n\n  /**\n   * Create a date in a specific timezone\n   * @param {number} year\n   * @param {number} month - 0-indexed\n   * @param {number} day\n   * @param {number} hour\n   * @param {number} minute\n   * @param {number} second\n   * @param {string} timeZone - IANA timezone string\n   * @returns {Date}\n   */\n  static createInTimeZone(year, month, day, hour = 0, minute = 0, second = 0, timeZone) {\n    // Create date string in ISO format\n    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;\n    const timeStr = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}`;\n\n    // Use Intl API to get the UTC time for this local time in the timezone\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      hour12: false\n    });\n\n    // Parse the local date in the target timezone\n    const localDate = new Date(`${dateStr}T${timeStr}`);\n\n    // Get offset and adjust\n    const offset = DateUtils.getTimezoneOffset(localDate, timeZone);\n    const utcTime = localDate.getTime() + (offset * 60000);\n\n    return new Date(utcTime);\n  }\n}","import { DateUtils } from '../calendar/DateUtils.js';\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\n/**\n * RecurrenceEngine - Handles expansion of recurring events\n * Supports a subset of RFC 5545 (iCalendar) RRULE specification\n */\nexport class RecurrenceEngine {\n  /**\n   * Expand a recurring event into individual occurrences\n   * @param {import('./Event.js').Event} event - The recurring event\n   * @param {Date} rangeStart - Start of the expansion range\n   * @param {Date} rangeEnd - End of the expansion range\n   * @param {number} [maxOccurrences=365] - Maximum number of occurrences to generate\n   * @param {string} [timezone] - Timezone for expansion (important for DST)\n   * @returns {import('../../types.js').EventOccurrence[]} Array of occurrence objects with start/end dates\n   */\n  static expandEvent(event, rangeStart, rangeEnd, maxOccurrences = 365, timezone = null) {\n    if (!event.recurring || !event.recurrenceRule) {\n      return [{ start: event.start, end: event.end, timezone: event.timeZone }];\n    }\n\n    const rule = this.parseRule(event.recurrenceRule);\n    const occurrences = [];\n    const duration = event.end - event.start;\n    const eventTimezone = timezone || event.timeZone || 'UTC';\n    const tzManager = new TimezoneManager();\n\n    // Work in event's timezone for accurate recurrence calculation\n    let currentDate = new Date(event.start);\n    let count = 0;\n\n    // If UNTIL is specified, use it as the range end\n    if (rule.until && rule.until < rangeEnd) {\n      rangeEnd = rule.until;\n    }\n\n    // Track DST transitions for proper timezone handling\n    let lastOffset = tzManager.getTimezoneOffset(currentDate, eventTimezone);\n\n    while (currentDate <= rangeEnd && count < maxOccurrences) {\n      // Check if this occurrence is within the range\n      if (currentDate >= rangeStart) {\n        const occurrenceStart = new Date(currentDate);\n        const occurrenceEnd = new Date(currentDate.getTime() + duration);\n\n        // Handle DST transitions\n        const currentOffset = tzManager.getTimezoneOffset(occurrenceStart, eventTimezone);\n        if (currentOffset !== lastOffset) {\n          // Adjust for DST change\n          const offsetDiff = lastOffset - currentOffset;\n          occurrenceStart.setMinutes(occurrenceStart.getMinutes() + offsetDiff);\n          occurrenceEnd.setMinutes(occurrenceEnd.getMinutes() + offsetDiff);\n        }\n        lastOffset = currentOffset;\n\n        // Apply exceptions if any\n        if (!this.isException(occurrenceStart, rule, event.id)) {\n          occurrences.push({\n            start: occurrenceStart,\n            end: occurrenceEnd,\n            recurringEventId: event.id,\n            timezone: eventTimezone,\n            originalStart: event.start\n          });\n        }\n      }\n\n      // Calculate next occurrence\n      currentDate = this.getNextOccurrence(currentDate, rule, eventTimezone);\n      count++;\n\n      // Check COUNT limit\n      if (rule.count && count >= rule.count) {\n        break;\n      }\n    }\n\n    return occurrences;\n  }\n\n  /**\n   * Parse an RRULE string into a rule object\n   * @param {string|import('../../types.js').RecurrenceRule} ruleString - RRULE string (e.g., \"FREQ=DAILY;INTERVAL=1;COUNT=10\") or rule object\n   * @returns {import('../../types.js').RecurrenceRule} Parsed rule object\n   */\n  static parseRule(ruleString) {\n    const rule = {\n      freq: null,\n      interval: 1,\n      count: null,\n      until: null,\n      byDay: [],\n      byMonthDay: [],\n      byMonth: [],\n      bySetPos: [],\n      exceptions: []\n    };\n\n    if (typeof ruleString === 'object') {\n      return { ...rule, ...ruleString };\n    }\n\n    const parts = ruleString.split(';');\n    parts.forEach(part => {\n      const [key, value] = part.split('=');\n      switch (key.toUpperCase()) {\n        case 'FREQ':\n          rule.freq = value.toUpperCase();\n          break;\n        case 'INTERVAL':\n          rule.interval = parseInt(value, 10);\n          break;\n        case 'COUNT':\n          rule.count = parseInt(value, 10);\n          break;\n        case 'UNTIL':\n          rule.until = this.parseDate(value);\n          break;\n        case 'BYDAY':\n          rule.byDay = value.split(',');\n          break;\n        case 'BYMONTHDAY':\n          rule.byMonthDay = value.split(',').map(d => parseInt(d, 10));\n          break;\n        case 'BYMONTH':\n          rule.byMonth = value.split(',').map(m => parseInt(m, 10));\n          break;\n        case 'BYSETPOS':\n          rule.bySetPos = value.split(',').map(p => parseInt(p, 10));\n          break;\n      }\n    });\n\n    return rule;\n  }\n\n  /**\n   * Calculate the next occurrence based on the rule\n   * @param {Date} currentDate - Current occurrence date\n   * @param {Object} rule - Recurrence rule object\n   * @param {string} [timezone] - Timezone for calculation\n   * @returns {Date} Next occurrence date\n   */\n  static getNextOccurrence(currentDate, rule, timezone = 'UTC') {\n    const next = new Date(currentDate);\n\n    switch (rule.freq) {\n      case 'DAILY':\n        next.setDate(next.getDate() + rule.interval);\n        break;\n\n      case 'WEEKLY':\n        if (rule.byDay && rule.byDay.length > 0) {\n          // Find next day that matches byDay\n          next.setDate(next.getDate() + 1);\n          while (!this.matchesByDay(next, rule.byDay)) {\n            next.setDate(next.getDate() + 1);\n          }\n        } else {\n          // Simple weekly recurrence\n          next.setDate(next.getDate() + (7 * rule.interval));\n        }\n        break;\n\n      case 'MONTHLY':\n        if (rule.byMonthDay && rule.byMonthDay.length > 0) {\n          // Specific day(s) of month\n          const currentMonth = next.getMonth();\n          next.setMonth(currentMonth + rule.interval);\n          next.setDate(rule.byMonthDay[0]); // Use first specified day\n        } else if (rule.byDay && rule.byDay.length > 0) {\n          // Specific weekday of month (e.g., \"2nd Tuesday\")\n          next.setMonth(next.getMonth() + rule.interval);\n          this.setToWeekdayOfMonth(next, rule.byDay[0], rule.bySetPos[0] || 1);\n        } else {\n          // Same day of month\n          next.setMonth(next.getMonth() + rule.interval);\n        }\n        break;\n\n      case 'YEARLY':\n        if (rule.byMonth && rule.byMonth.length > 0) {\n          next.setFullYear(next.getFullYear() + rule.interval);\n          next.setMonth(rule.byMonth[0] - 1); // Months are 0-indexed\n        } else {\n          next.setFullYear(next.getFullYear() + rule.interval);\n        }\n        break;\n\n      default:\n        // Unsupported frequency\n        next.setTime(next.getTime() + (24 * 60 * 60 * 1000)); // Daily fallback\n    }\n\n    return next;\n  }\n\n  /**\n   * Check if a date matches the BYDAY rule\n   * @param {Date} date - Date to check\n   * @param {Array<string>} byDay - Array of day codes (e.g., ['MO', 'WE', 'FR'])\n   * @returns {boolean}\n   */\n  static matchesByDay(date, byDay) {\n    const dayMap = {\n      'SU': 0, 'MO': 1, 'TU': 2, 'WE': 3,\n      'TH': 4, 'FR': 5, 'SA': 6\n    };\n\n    const dayOfWeek = date.getDay();\n    return byDay.some(day => {\n      // Handle numbered weekdays (e.g., \"2MO\" for 2nd Monday)\n      const match = day.match(/^(-?\\d+)?([A-Z]{2})$/);\n      if (match) {\n        const weekdayCode = match[2];\n        return dayMap[weekdayCode] === dayOfWeek;\n      }\n      return false;\n    });\n  }\n\n  /**\n   * Set date to specific weekday of month\n   * @param {Date} date - Date to modify\n   * @param {string} weekday - Weekday code (e.g., 'MO', 'TU')\n   * @param {number} position - Position in month (1-5, or -1 for last)\n   */\n  static setToWeekdayOfMonth(date, weekday, position = 1) {\n    const dayMap = {\n      'SU': 0, 'MO': 1, 'TU': 2, 'WE': 3,\n      'TH': 4, 'FR': 5, 'SA': 6\n    };\n\n    // Extract weekday code if it has a number prefix\n    const match = weekday.match(/^(-?\\d+)?([A-Z]{2})$/);\n    const weekdayCode = match ? match[2] : weekday;\n    const targetDay = dayMap[weekdayCode];\n\n    date.setDate(1); // Start at first of month\n\n    // Find first occurrence of the weekday\n    while (date.getDay() !== targetDay) {\n      date.setDate(date.getDate() + 1);\n    }\n\n    // Move to the nth occurrence\n    if (position > 1) {\n      date.setDate(date.getDate() + (7 * (position - 1)));\n    } else if (position === -1) {\n      // Last occurrence of the month\n      const nextMonth = new Date(date);\n      nextMonth.setMonth(nextMonth.getMonth() + 1);\n      nextMonth.setDate(0); // Last day of current month\n\n      while (nextMonth.getDay() !== targetDay) {\n        nextMonth.setDate(nextMonth.getDate() - 1);\n      }\n      date.setTime(nextMonth.getTime());\n    }\n  }\n\n  /**\n   * Check if a date is an exception\n   * @param {Date} date - Date to check\n   * @param {Object} rule - Rule object with exceptions\n   * @param {string} [eventId] - Event ID for better exception tracking\n   * @returns {boolean}\n   */\n  static isException(date, rule, eventId = null) {\n    if (!rule.exceptions || rule.exceptions.length === 0) {\n      return false;\n    }\n\n    // Support both date-only and date-time exceptions\n    const dateStr = date.toDateString();\n    const dateTime = date.getTime();\n\n    return rule.exceptions.some(exDate => {\n      if (typeof exDate === 'object' && exDate.date) {\n        // Enhanced exception format with reason\n        const exceptionDate = exDate.date instanceof Date ? exDate.date : new Date(exDate.date);\n        if (exDate.matchTime) {\n          return Math.abs(exceptionDate.getTime() - dateTime) < 1000; // Within 1 second\n        }\n        return exceptionDate.toDateString() === dateStr;\n      } else {\n        // Simple date exception\n        const exceptionDate = exDate instanceof Date ? exDate : new Date(exDate);\n        return exceptionDate.toDateString() === dateStr;\n      }\n    });\n  }\n\n  /**\n   * Add exception dates to a recurrence rule\n   * @param {Object} rule - Recurrence rule\n   * @param {Date|Date[]} exceptions - Exception date(s) to add\n   * @param {Object} [options] - Options for exception\n   * @returns {Object} Updated rule\n   */\n  static addExceptions(rule, exceptions, options = {}) {\n    if (!rule.exceptions) {\n      rule.exceptions = [];\n    }\n\n    const exceptionArray = Array.isArray(exceptions) ? exceptions : [exceptions];\n\n    exceptionArray.forEach(date => {\n      if (options.reason || options.matchTime) {\n        rule.exceptions.push({\n          date: date,\n          reason: options.reason,\n          matchTime: options.matchTime || false\n        });\n      } else {\n        rule.exceptions.push(date);\n      }\n    });\n\n    return rule;\n  }\n\n  /**\n   * Parse date from RRULE format (YYYYMMDDTHHMMSSZ)\n   * @param {string} dateStr - Date string in RRULE format\n   * @returns {Date}\n   */\n  static parseDate(dateStr) {\n    if (dateStr.length === 8) {\n      // YYYYMMDD\n      const year = parseInt(dateStr.substr(0, 4), 10);\n      const month = parseInt(dateStr.substr(4, 2), 10) - 1;\n      const day = parseInt(dateStr.substr(6, 2), 10);\n      return new Date(year, month, day);\n    } else if (dateStr.length === 15 || dateStr.length === 16) {\n      // YYYYMMDDTHHMMSS[Z]\n      const year = parseInt(dateStr.substr(0, 4), 10);\n      const month = parseInt(dateStr.substr(4, 2), 10) - 1;\n      const day = parseInt(dateStr.substr(6, 2), 10);\n      const hour = parseInt(dateStr.substr(9, 2), 10);\n      const minute = parseInt(dateStr.substr(11, 2), 10);\n      const second = parseInt(dateStr.substr(13, 2), 10);\n\n      if (dateStr.endsWith('Z')) {\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n      } else {\n        return new Date(year, month, day, hour, minute, second);\n      }\n    }\n\n    // Fallback to standard date parsing\n    return new Date(dateStr);\n  }\n\n  /**\n   * Generate a human-readable description of the recurrence rule\n   * @param {Object|string} rule - Recurrence rule\n   * @returns {string} Human-readable description\n   */\n  static getDescription(rule) {\n    if (typeof rule === 'string') {\n      rule = this.parseRule(rule);\n    }\n\n    let description = '';\n    const interval = rule.interval || 1;\n\n    switch (rule.freq) {\n      case 'DAILY':\n        description = interval === 1 ? 'Daily' : `Every ${interval} days`;\n        break;\n      case 'WEEKLY':\n        description = interval === 1 ? 'Weekly' : `Every ${interval} weeks`;\n        if (rule.byDay && rule.byDay.length > 0) {\n          const days = rule.byDay.map(d => this.getDayName(d)).join(', ');\n          description += ` on ${days}`;\n        }\n        break;\n      case 'MONTHLY':\n        description = interval === 1 ? 'Monthly' : `Every ${interval} months`;\n        if (rule.byMonthDay && rule.byMonthDay.length > 0) {\n          description += ` on day ${rule.byMonthDay.join(', ')}`;\n        }\n        break;\n      case 'YEARLY':\n        description = interval === 1 ? 'Yearly' : `Every ${interval} years`;\n        break;\n    }\n\n    if (rule.count) {\n      description += `, ${rule.count} times`;\n    } else if (rule.until) {\n      description += `, until ${rule.until.toLocaleDateString()}`;\n    }\n\n    return description;\n  }\n\n  /**\n   * Get day name from RRULE day code\n   * @param {string} dayCode - Day code (e.g., 'MO', '2TU')\n   * @returns {string} Day name\n   */\n  static getDayName(dayCode) {\n    const dayNames = {\n      'SU': 'Sunday', 'MO': 'Monday', 'TU': 'Tuesday',\n      'WE': 'Wednesday', 'TH': 'Thursday', 'FR': 'Friday',\n      'SA': 'Saturday'\n    };\n\n    // Extract day code if it has a number prefix\n    const match = dayCode.match(/^(-?\\d+)?([A-Z]{2})$/);\n    const code = match ? match[2] : dayCode;\n    const position = match && match[1] ? parseInt(match[1], 10) : null;\n\n    let name = dayNames[code] || dayCode;\n\n    if (position) {\n      const ordinals = ['', '1st', '2nd', '3rd', '4th', '5th'];\n      const ordinal = position === -1 ? 'Last' : (ordinals[position] || `${position}th`);\n      name = `${ordinal} ${name}`;\n    }\n\n    return name;\n  }\n}","/**\n * LRU (Least Recently Used) Cache implementation\n * Provides O(1) get and put operations\n */\nexport class LRUCache {\n  /**\n   * Create a new LRU Cache\n   * @param {number} capacity - Maximum number of items in cache\n   */\n  constructor(capacity = 100) {\n    this.capacity = capacity;\n    this.cache = new Map();\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  /**\n   * Get a value from the cache\n   * @param {string} key - Cache key\n   * @returns {*} Cached value or undefined\n   */\n  get(key) {\n    if (!this.cache.has(key)) {\n      this.misses++;\n      return undefined;\n    }\n\n    // Move to end (most recently used)\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    this.hits++;\n    return value;\n  }\n\n  /**\n   * Put a value in the cache\n   * @param {string} key - Cache key\n   * @param {*} value - Value to cache\n   */\n  put(key, value) {\n    // Remove if exists to update position\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      // Remove least recently used (first item)\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n      this.evictions++;\n    }\n\n    this.cache.set(key, value);\n  }\n\n  /**\n   * Check if key exists in cache\n   * @param {string} key - Cache key\n   * @returns {boolean} True if key exists\n   */\n  has(key) {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Remove a key from the cache\n   * @param {string} key - Cache key\n   * @returns {boolean} True if key was removed\n   */\n  delete(key) {\n    return this.cache.delete(key);\n  }\n\n  /**\n   * Clear all cached items\n   */\n  clear() {\n    this.cache.clear();\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  /**\n   * Get cache statistics\n   * @returns {Object} Cache stats\n   */\n  getStats() {\n    const hitRate = this.hits + this.misses > 0\n      ? (this.hits / (this.hits + this.misses) * 100).toFixed(2)\n      : 0;\n\n    return {\n      size: this.cache.size,\n      capacity: this.capacity,\n      hits: this.hits,\n      misses: this.misses,\n      evictions: this.evictions,\n      hitRate: `${hitRate}%`\n    };\n  }\n\n  /**\n   * Get all keys in order (least to most recently used)\n   * @returns {string[]} Array of keys\n   */\n  keys() {\n    return Array.from(this.cache.keys());\n  }\n\n  /**\n   * Get cache size\n   * @returns {number} Number of items in cache\n   */\n  get size() {\n    return this.cache.size;\n  }\n}","/**\n * PerformanceOptimizer - Optimizes calendar operations for large datasets\n * Includes caching, lazy loading, and batch processing\n */\n\nimport { LRUCache } from './LRUCache.js';\n\nexport class PerformanceOptimizer {\n  constructor(config = {}) {\n    // Configuration\n    this.config = {\n      enableCache: true,\n      cacheCapacity: 500,\n      maxIndexDays: 365,\n      batchSize: 100,\n      enableMetrics: true,\n      cleanupInterval: 3600000, // 1 hour in ms\n      maxIndexAge: 30 * 24 * 60 * 60 * 1000, // 30 days in ms\n      ...config\n    };\n\n    // Caches\n    this.eventCache = new LRUCache(this.config.cacheCapacity);\n    this.queryCache = new LRUCache(Math.floor(this.config.cacheCapacity / 2));\n    this.dateRangeCache = new LRUCache(Math.floor(this.config.cacheCapacity / 4));\n\n    // Lazy loading tracking\n    this.lazyIndexes = new Map(); // eventId -> Set of date strings\n    this.pendingIndexes = new Map(); // eventId -> Promise\n\n    // Batch processing\n    this.batchQueue = [];\n    this.batchTimer = null;\n    this.batchCallbacks = [];\n\n    // Performance metrics\n    this.metrics = {\n      operations: {},\n      averageTimes: {},\n      slowQueries: []\n    };\n\n    // Cleanup timer\n    this.cleanupTimer = null;\n    if (this.config.cleanupInterval > 0) {\n      this.startCleanupTimer();\n    }\n  }\n\n  /**\n   * Measure operation performance\n   * @param {string} operation - Operation name\n   * @param {Function} fn - Function to measure\n   * @returns {*} Function result\n   */\n  measure(operation, fn) {\n    if (!this.config.enableMetrics) {\n      return fn();\n    }\n\n    const start = performance.now();\n    try {\n      const result = fn();\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration);\n      return result;\n    } catch (error) {\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Measure async operation performance\n   * @param {string} operation - Operation name\n   * @param {Function} fn - Async function to measure\n   * @returns {Promise<*>} Function result\n   */\n  async measureAsync(operation, fn) {\n    if (!this.config.enableMetrics) {\n      return await fn();\n    }\n\n    const start = performance.now();\n    try {\n      const result = await fn();\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration);\n      return result;\n    } catch (error) {\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Record performance metric\n   * @private\n   */\n  recordMetric(operation, duration, isError = false) {\n    if (!this.metrics.operations[operation]) {\n      this.metrics.operations[operation] = {\n        count: 0,\n        totalTime: 0,\n        errors: 0,\n        min: Infinity,\n        max: 0\n      };\n    }\n\n    const metric = this.metrics.operations[operation];\n    metric.count++;\n    metric.totalTime += duration;\n    metric.min = Math.min(metric.min, duration);\n    metric.max = Math.max(metric.max, duration);\n\n    if (isError) {\n      metric.errors++;\n    }\n\n    // Update average\n    this.metrics.averageTimes[operation] = metric.totalTime / metric.count;\n\n    // Track slow queries\n    if (duration > 100) {\n      this.metrics.slowQueries.push({\n        operation,\n        duration,\n        timestamp: new Date(),\n        isError\n      });\n\n      // Keep only last 100 slow queries\n      if (this.metrics.slowQueries.length > 100) {\n        this.metrics.slowQueries.shift();\n      }\n    }\n  }\n\n  /**\n   * Get performance metrics\n   * @returns {Object} Performance metrics\n   */\n  getMetrics() {\n    const summary = {\n      cacheStats: {\n        event: this.eventCache.getStats(),\n        query: this.queryCache.getStats(),\n        dateRange: this.dateRangeCache.getStats()\n      },\n      operations: {},\n      slowestOperations: [],\n      recentSlowQueries: this.metrics.slowQueries.slice(-10)\n    };\n\n    // Process operations\n    for (const [op, data] of Object.entries(this.metrics.operations)) {\n      summary.operations[op] = {\n        count: data.count,\n        avgTime: `${(data.totalTime / data.count).toFixed(2)}ms`,\n        minTime: `${data.min.toFixed(2)}ms`,\n        maxTime: `${data.max.toFixed(2)}ms`,\n        totalTime: `${data.totalTime.toFixed(2)}ms`,\n        errors: data.errors,\n        errorRate: `${((data.errors / data.count) * 100).toFixed(2)}%`\n      };\n    }\n\n    // Find slowest operations\n    summary.slowestOperations = Object.entries(this.metrics.averageTimes)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(([op, time]) => ({\n        operation: op,\n        avgTime: `${time.toFixed(2)}ms`\n      }));\n\n    return summary;\n  }\n\n  /**\n   * Check if event should use lazy indexing\n   * @param {import('../events/Event.js').Event} event - Event to check\n   * @returns {boolean} True if should use lazy indexing\n   */\n  shouldUseLazyIndexing(event) {\n    const daySpan = Math.ceil(\n      (event.end - event.start) / (24 * 60 * 60 * 1000)\n    );\n    return daySpan > this.config.maxIndexDays;\n  }\n\n  /**\n   * Create lazy index markers for large events\n   * @param {import('../events/Event.js').Event} event - Event to index\n   * @returns {Object} Index boundaries\n   */\n  createLazyIndexMarkers(event) {\n    const markers = {\n      eventId: event.id,\n      start: event.start,\n      end: event.end,\n      indexed: new Set(),\n      pending: false\n    };\n\n    // Index first and last month only initially\n    const startMonth = new Date(event.start.getFullYear(), event.start.getMonth(), 1);\n    const endMonth = new Date(event.end.getFullYear(), event.end.getMonth(), 1);\n\n    markers.indexed.add(this.getMonthKey(startMonth));\n    if (this.getMonthKey(startMonth) !== this.getMonthKey(endMonth)) {\n      markers.indexed.add(this.getMonthKey(endMonth));\n    }\n\n    this.lazyIndexes.set(event.id, markers);\n    return markers;\n  }\n\n  /**\n   * Expand lazy index for a specific date range\n   * @param {string} eventId - Event ID\n   * @param {Date} rangeStart - Start of range to index\n   * @param {Date} rangeEnd - End of range to index\n   * @returns {Promise<Set<string>>} Indexed date strings\n   */\n  async expandLazyIndex(eventId, rangeStart, rangeEnd) {\n    const markers = this.lazyIndexes.get(eventId);\n    if (!markers) {\n      return new Set();\n    }\n\n    // Check if already pending\n    if (markers.pending) {\n      return this.pendingIndexes.get(eventId);\n    }\n\n    markers.pending = true;\n\n    const promise = new Promise((resolve) => {\n      // Simulate async indexing (in real app, could be in worker)\n      setTimeout(() => {\n        const indexed = new Set();\n        const current = new Date(rangeStart);\n\n        while (current <= rangeEnd) {\n          const dateStr = current.toDateString();\n          if (!markers.indexed.has(dateStr)) {\n            indexed.add(dateStr);\n            markers.indexed.add(dateStr);\n          }\n          current.setDate(current.getDate() + 1);\n        }\n\n        markers.pending = false;\n        this.pendingIndexes.delete(eventId);\n        resolve(indexed);\n      }, 0);\n    });\n\n    this.pendingIndexes.set(eventId, promise);\n    return promise;\n  }\n\n  /**\n   * Get month key for date\n   * @private\n   */\n  getMonthKey(date) {\n    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n  }\n\n  /**\n   * Cache event with TTL\n   * @param {string} key - Cache key\n   * @param {*} value - Value to cache\n   * @param {string} cacheType - Type of cache to use\n   */\n  cache(key, value, cacheType = 'event') {\n    if (!this.config.enableCache) return;\n\n    switch (cacheType) {\n      case 'event':\n        this.eventCache.put(key, value);\n        break;\n      case 'query':\n        this.queryCache.put(key, value);\n        break;\n      case 'dateRange':\n        this.dateRangeCache.put(key, value);\n        break;\n    }\n  }\n\n  /**\n   * Get from cache\n   * @param {string} key - Cache key\n   * @param {string} cacheType - Type of cache\n   * @returns {*} Cached value or undefined\n   */\n  getFromCache(key, cacheType = 'event') {\n    if (!this.config.enableCache) return undefined;\n\n    switch (cacheType) {\n      case 'event':\n        return this.eventCache.get(key);\n      case 'query':\n        return this.queryCache.get(key);\n      case 'dateRange':\n        return this.dateRangeCache.get(key);\n      default:\n        return undefined;\n    }\n  }\n\n  /**\n   * Invalidate caches for an event\n   * @param {string} eventId - Event ID\n   */\n  invalidateEventCaches(eventId) {\n    // Remove from event cache\n    this.eventCache.delete(eventId);\n\n    // Clear query cache (conservative approach)\n    // In production, track which queries include this event\n    this.queryCache.clear();\n    this.dateRangeCache.clear();\n  }\n\n  /**\n   * Batch operation for efficiency\n   * @param {Function} operation - Operation to batch\n   * @returns {Promise} Batch result\n   */\n  batch(operation) {\n    return new Promise((resolve, reject) => {\n      this.batchQueue.push(operation);\n      this.batchCallbacks.push({ resolve, reject });\n\n      if (this.batchQueue.length >= this.config.batchSize) {\n        this.processBatch();\n      } else if (!this.batchTimer) {\n        // Process batch after 10ms if not full\n        this.batchTimer = setTimeout(() => this.processBatch(), 10);\n      }\n    });\n  }\n\n  /**\n   * Process batched operations\n   * @private\n   */\n  processBatch() {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n\n    if (this.batchQueue.length === 0) return;\n\n    const operations = this.batchQueue.splice(0);\n    const callbacks = this.batchCallbacks.splice(0);\n\n    // Process all operations\n    const results = [];\n    const errors = [];\n\n    operations.forEach((op, index) => {\n      try {\n        results[index] = op();\n      } catch (error) {\n        errors[index] = error;\n      }\n    });\n\n    // Resolve callbacks\n    callbacks.forEach((callback, index) => {\n      if (errors[index]) {\n        callback.reject(errors[index]);\n      } else {\n        callback.resolve(results[index]);\n      }\n    });\n  }\n\n  /**\n   * Start cleanup timer for old indexes\n   * @private\n   */\n  startCleanupTimer() {\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupOldIndexes();\n    }, this.config.cleanupInterval);\n  }\n\n  /**\n   * Clean up old indexes\n   * @private\n   */\n  cleanupOldIndexes() {\n    const now = Date.now();\n    const maxAge = this.config.maxIndexAge;\n\n    // Clean up lazy indexes for events that are too old\n    for (const [eventId, markers] of this.lazyIndexes) {\n      if (markers.end.getTime() < now - maxAge) {\n        this.lazyIndexes.delete(eventId);\n      }\n    }\n\n    // Clean up slow query log\n    if (this.metrics.slowQueries.length > 100) {\n      this.metrics.slowQueries = this.metrics.slowQueries.slice(-100);\n    }\n  }\n\n  /**\n   * Optimize query by checking cache first\n   * @param {string} queryKey - Unique query identifier\n   * @param {Function} queryFn - Function to execute if not cached\n   * @returns {*} Query result\n   */\n  optimizeQuery(queryKey, queryFn) {\n    // Check cache first\n    const cached = this.getFromCache(queryKey, 'query');\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    // Execute query and cache result\n    const result = this.measure(`query:${queryKey}`, queryFn);\n    this.cache(queryKey, result, 'query');\n    return result;\n  }\n\n  /**\n   * Destroy optimizer and clean up resources\n   */\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n\n    this.eventCache.clear();\n    this.queryCache.clear();\n    this.dateRangeCache.clear();\n    this.lazyIndexes.clear();\n    this.pendingIndexes.clear();\n  }\n}","/**\n * ConflictDetector - Detects scheduling conflicts between events\n * Checks for time overlaps, attendee conflicts, and resource conflicts\n */\n\nimport { DateUtils } from '../calendar/DateUtils.js';\n\nexport class ConflictDetector {\n  /**\n   * Create a new ConflictDetector\n   * @param {import('../events/EventStore.js').EventStore} eventStore - Event store instance\n   */\n  constructor(eventStore) {\n    this.eventStore = eventStore;\n    this.conflictIdCounter = 0;\n  }\n\n  /**\n   * Check for conflicts for a specific event\n   * @param {import('../events/Event.js').Event|import('../../types.js').EventData} event - Event to check\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictSummary} Conflict summary\n   */\n  checkConflicts(event, options = {}) {\n    // Default options\n    const opts = {\n      checkAttendees: true,\n      checkResources: true,\n      checkLocation: true,\n      ignoreAllDay: false,\n      excludeEventIds: [],\n      includeStatuses: ['confirmed', 'tentative'],\n      bufferMinutes: 0,\n      ...options\n    };\n\n    // Ensure we have an Event object\n    if (!event.start || !event.end) {\n      throw new Error('Event must have start and end dates');\n    }\n\n    const conflicts = [];\n    const affectedEventIds = new Set();\n    const affectedAttendees = new Set();\n\n    // Get potential conflicting events in the time range\n    const searchStart = new Date(event.start.getTime() - opts.bufferMinutes * 60000);\n    const searchEnd = new Date(event.end.getTime() + opts.bufferMinutes * 60000);\n\n    const potentialConflicts = this.eventStore.getEventsInRange(searchStart, searchEnd, false)\n      .filter(e => {\n        // Exclude self\n        if (e.id === event.id) return false;\n        // Exclude specified event IDs\n        if (opts.excludeEventIds.includes(e.id)) return false;\n        // Filter by status\n        if (!opts.includeStatuses.includes(e.status)) return false;\n        // Ignore all-day events if specified\n        if (opts.ignoreAllDay && (e.allDay || event.allDay)) return false;\n        // Ignore cancelled events\n        if (e.status === 'cancelled') return false;\n        return true;\n      });\n\n    // Check each potential conflict\n    for (const conflictingEvent of potentialConflicts) {\n      const eventConflicts = this._detectEventConflicts(\n        event,\n        conflictingEvent,\n        opts\n      );\n\n      if (eventConflicts.length > 0) {\n        conflicts.push(...eventConflicts);\n        affectedEventIds.add(event.id);\n        affectedEventIds.add(conflictingEvent.id);\n\n        // Track affected attendees\n        if (event.attendees) {\n          event.attendees.forEach(a => affectedAttendees.add(a.email));\n        }\n        if (conflictingEvent.attendees) {\n          conflictingEvent.attendees.forEach(a => affectedAttendees.add(a.email));\n        }\n      }\n    }\n\n    // Build summary\n    return this._buildConflictSummary(conflicts, affectedEventIds, affectedAttendees);\n  }\n\n  /**\n   * Check for conflicts between two specific events\n   * @param {import('../events/Event.js').Event} event1 - First event\n   * @param {import('../events/Event.js').Event} event2 - Second event\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictDetails[]} Array of conflicts\n   */\n  checkEventPairConflicts(event1, event2, options = {}) {\n    const opts = {\n      checkAttendees: true,\n      checkResources: true,\n      checkLocation: true,\n      bufferMinutes: 0,\n      ...options\n    };\n\n    return this._detectEventConflicts(event1, event2, opts);\n  }\n\n  /**\n   * Get busy periods for a set of attendees\n   * @param {string[]} attendeeEmails - Attendee email addresses\n   * @param {Date} start - Start of period\n   * @param {Date} end - End of period\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date, eventIds: string[]}>} Busy periods\n   */\n  getBusyPeriods(attendeeEmails, start, end, options = {}) {\n    const opts = {\n      includeStatuses: ['confirmed', 'tentative'],\n      mergePeriods: true,\n      ...options\n    };\n\n    const busyPeriods = [];\n    const events = this.eventStore.getEventsInRange(start, end, false);\n\n    // Find events with these attendees\n    const attendeeEvents = events.filter(event => {\n      if (!opts.includeStatuses.includes(event.status)) return false;\n      if (event.status === 'cancelled') return false;\n\n      return event.attendees && event.attendees.some(attendee =>\n        attendeeEmails.includes(attendee.email)\n      );\n    });\n\n    // Convert to busy periods\n    attendeeEvents.forEach(event => {\n      busyPeriods.push({\n        start: event.start,\n        end: event.end,\n        eventIds: [event.id]\n      });\n    });\n\n    // Merge overlapping periods if requested\n    if (opts.mergePeriods && busyPeriods.length > 1) {\n      return this._mergeBusyPeriods(busyPeriods);\n    }\n\n    return busyPeriods.sort((a, b) => a.start - b.start);\n  }\n\n  /**\n   * Get free time slots\n   * @param {Date} start - Start of search period\n   * @param {Date} end - End of search period\n   * @param {number} duration - Required duration in minutes\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date}>} Free time slots\n   */\n  getFreePeriods(start, end, duration, options = {}) {\n    const opts = {\n      attendeeEmails: [],\n      businessHoursOnly: false,\n      businessHours: { start: '09:00', end: '17:00' },\n      excludeWeekends: false,\n      ...options\n    };\n\n    const freePeriods = [];\n\n    // Get busy periods\n    const busyPeriods = opts.attendeeEmails.length > 0\n      ? this.getBusyPeriods(opts.attendeeEmails, start, end)\n      : this._getAllBusyPeriods(start, end);\n\n    // Find gaps between busy periods\n    let currentTime = new Date(start);\n\n    for (const busy of busyPeriods) {\n      if (currentTime < busy.start) {\n        // Found a gap\n        const gapDuration = (busy.start - currentTime) / 60000; // minutes\n        if (gapDuration >= duration) {\n          // Check if within business hours if required\n          if (!opts.businessHoursOnly || this._isWithinBusinessHours(currentTime, busy.start, opts)) {\n            freePeriods.push({\n              start: new Date(currentTime),\n              end: new Date(busy.start)\n            });\n          }\n        }\n      }\n      currentTime = new Date(Math.max(currentTime.getTime(), busy.end.getTime()));\n    }\n\n    // Check final period\n    if (currentTime < end) {\n      const gapDuration = (end - currentTime) / 60000;\n      if (gapDuration >= duration) {\n        if (!opts.businessHoursOnly || this._isWithinBusinessHours(currentTime, end, opts)) {\n          freePeriods.push({\n            start: new Date(currentTime),\n            end: new Date(end)\n          });\n        }\n      }\n    }\n\n    return freePeriods;\n  }\n\n  /**\n   * Detect conflicts between two events\n   * @private\n   */\n  _detectEventConflicts(event1, event2, options) {\n    const conflicts = [];\n\n    // Check time overlap with buffer\n    const hasTimeOverlap = this._checkTimeOverlap(\n      event1,\n      event2,\n      options.bufferMinutes\n    );\n\n    if (hasTimeOverlap) {\n      // Time conflict\n      const timeConflict = this._createTimeConflict(event1, event2);\n      conflicts.push(timeConflict);\n\n      // Check attendee conflicts (only if time overlaps)\n      if (options.checkAttendees) {\n        const attendeeConflicts = this._checkAttendeeConflicts(event1, event2);\n        conflicts.push(...attendeeConflicts);\n      }\n\n      // Check resource conflicts (only if time overlaps)\n      if (options.checkResources) {\n        const resourceConflicts = this._checkResourceConflicts(event1, event2);\n        conflicts.push(...resourceConflicts);\n      }\n\n      // Check location conflicts (only if time overlaps)\n      if (options.checkLocation) {\n        const locationConflict = this._checkLocationConflict(event1, event2);\n        if (locationConflict) {\n          conflicts.push(locationConflict);\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for time overlap between events\n   * @private\n   */\n  _checkTimeOverlap(event1, event2, bufferMinutes = 0) {\n    const buffer = bufferMinutes * 60000; // Convert to milliseconds\n\n    const start1 = event1.start.getTime() - buffer;\n    const end1 = event1.end.getTime() + buffer;\n    const start2 = event2.start.getTime();\n    const end2 = event2.end.getTime();\n\n    return !(end1 <= start2 || end2 <= start1);\n  }\n\n  /**\n   * Create time conflict details\n   * @private\n   */\n  _createTimeConflict(event1, event2) {\n    const overlapStart = new Date(Math.max(event1.start.getTime(), event2.start.getTime()));\n    const overlapEnd = new Date(Math.min(event1.end.getTime(), event2.end.getTime()));\n    const overlapMinutes = (overlapEnd - overlapStart) / 60000;\n\n    // Determine severity based on overlap duration and event importance\n    let severity = 'low';\n    if (overlapMinutes >= 60) {\n      severity = 'high';\n    } else if (overlapMinutes >= 30) {\n      severity = 'medium';\n    }\n\n    // Increase severity for confirmed events\n    if (event1.status === 'confirmed' && event2.status === 'confirmed') {\n      severity = severity === 'low' ? 'medium' : severity === 'medium' ? 'high' : 'critical';\n    }\n\n    return {\n      id: `conflict_${++this.conflictIdCounter}`,\n      type: 'time',\n      severity,\n      eventId: event1.id,\n      conflictingEventId: event2.id,\n      description: `Time overlap: ${event1.title} conflicts with ${event2.title}`,\n      overlapStart,\n      overlapEnd,\n      overlapMinutes,\n      metadata: {\n        event1Title: event1.title,\n        event2Title: event2.title,\n        event1Status: event1.status,\n        event2Status: event2.status\n      }\n    };\n  }\n\n  /**\n   * Check for attendee conflicts\n   * @private\n   */\n  _checkAttendeeConflicts(event1, event2) {\n    const conflicts = [];\n\n    if (!event1.attendees || !event2.attendees) {\n      return conflicts;\n    }\n\n    const conflictingAttendees = [];\n\n    for (const attendee1 of event1.attendees) {\n      for (const attendee2 of event2.attendees) {\n        if (attendee1.email === attendee2.email) {\n          // Same attendee in both events\n          conflictingAttendees.push(attendee1.email);\n        }\n      }\n    }\n\n    if (conflictingAttendees.length > 0) {\n      // Determine severity based on attendee responses\n      let severity = 'medium';\n\n      // Check if any conflicting attendee has accepted both\n      const hasAcceptedBoth = conflictingAttendees.some(email => {\n        const a1 = event1.attendees.find(a => a.email === email);\n        const a2 = event2.attendees.find(a => a.email === email);\n        return a1?.responseStatus === 'accepted' && a2?.responseStatus === 'accepted';\n      });\n\n      if (hasAcceptedBoth) {\n        severity = 'critical';\n      }\n\n      conflicts.push({\n        id: `conflict_${++this.conflictIdCounter}`,\n        type: 'attendee',\n        severity,\n        eventId: event1.id,\n        conflictingEventId: event2.id,\n        description: `Attendee conflict: ${conflictingAttendees.length} attendee(s) double-booked`,\n        conflictingAttendees,\n        metadata: {\n          attendeeCount: conflictingAttendees.length,\n          attendeeEmails: conflictingAttendees\n        }\n      });\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for resource conflicts\n   * @private\n   */\n  _checkResourceConflicts(event1, event2) {\n    const conflicts = [];\n\n    // Check if events have resource attendees\n    const resources1 = event1.attendees?.filter(a => a.resource) || [];\n    const resources2 = event2.attendees?.filter(a => a.resource) || [];\n\n    for (const resource1 of resources1) {\n      for (const resource2 of resources2) {\n        if (resource1.email === resource2.email) {\n          conflicts.push({\n            id: `conflict_${++this.conflictIdCounter}`,\n            type: 'resource',\n            severity: 'critical', // Resource conflicts are always critical\n            eventId: event1.id,\n            conflictingEventId: event2.id,\n            description: `Resource conflict: ${resource1.name} is double-booked`,\n            conflictingResource: resource1.email,\n            metadata: {\n              resourceName: resource1.name,\n              resourceEmail: resource1.email\n            }\n          });\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for location conflicts\n   * @private\n   */\n  _checkLocationConflict(event1, event2) {\n    if (!event1.location || !event2.location) {\n      return null;\n    }\n\n    // Normalize locations for comparison\n    const loc1 = event1.location.trim().toLowerCase();\n    const loc2 = event2.location.trim().toLowerCase();\n\n    if (loc1 === loc2) {\n      return {\n        id: `conflict_${++this.conflictIdCounter}`,\n        type: 'location',\n        severity: 'high', // Location conflicts are typically high severity\n        eventId: event1.id,\n        conflictingEventId: event2.id,\n        description: `Location conflict: ${event1.location} is double-booked`,\n        metadata: {\n          location: event1.location\n        }\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Build conflict summary\n   * @private\n   */\n  _buildConflictSummary(conflicts, affectedEventIds, affectedAttendees) {\n    const conflictsByType = {};\n    const conflictsBySeverity = {};\n\n    // Count by type and severity\n    for (const conflict of conflicts) {\n      conflictsByType[conflict.type] = (conflictsByType[conflict.type] || 0) + 1;\n      conflictsBySeverity[conflict.severity] = (conflictsBySeverity[conflict.severity] || 0) + 1;\n    }\n\n    return {\n      hasConflicts: conflicts.length > 0,\n      totalConflicts: conflicts.length,\n      conflicts,\n      conflictsByType,\n      conflictsBySeverity,\n      affectedEventIds: Array.from(affectedEventIds),\n      affectedAttendees: Array.from(affectedAttendees)\n    };\n  }\n\n  /**\n   * Merge overlapping busy periods\n   * @private\n   */\n  _mergeBusyPeriods(periods) {\n    if (periods.length <= 1) return periods;\n\n    // Sort by start time\n    periods.sort((a, b) => a.start - b.start);\n\n    const merged = [periods[0]];\n\n    for (let i = 1; i < periods.length; i++) {\n      const current = periods[i];\n      const last = merged[merged.length - 1];\n\n      if (current.start <= last.end) {\n        // Overlapping or adjacent, merge them\n        last.end = new Date(Math.max(last.end.getTime(), current.end.getTime()));\n        last.eventIds.push(...current.eventIds);\n      } else {\n        // No overlap, add as new period\n        merged.push(current);\n      }\n    }\n\n    return merged;\n  }\n\n  /**\n   * Get all busy periods\n   * @private\n   */\n  _getAllBusyPeriods(start, end) {\n    const events = this.eventStore.getEventsInRange(start, end, false)\n      .filter(e => e.status !== 'cancelled');\n\n    return events.map(event => ({\n      start: event.start,\n      end: event.end,\n      eventIds: [event.id]\n    })).sort((a, b) => a.start - b.start);\n  }\n\n  /**\n   * Check if time period is within business hours\n   * @private\n   */\n  _isWithinBusinessHours(start, end, options) {\n    // Simple implementation - can be enhanced\n    const startHour = start.getHours();\n    const endHour = end.getHours();\n\n    const businessStart = parseInt(options.businessHours.start.split(':')[0]);\n    const businessEnd = parseInt(options.businessHours.end.split(':')[0]);\n\n    return startHour >= businessStart && endHour <= businessEnd;\n  }\n}","import { Event } from './Event.js';\nimport { DateUtils } from '../calendar/DateUtils.js';\nimport { RecurrenceEngine } from './RecurrenceEngine.js';\nimport { PerformanceOptimizer } from '../performance/PerformanceOptimizer.js';\nimport { ConflictDetector } from '../conflicts/ConflictDetector.js';\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\n/**\n * EventStore - Manages calendar events with efficient querying\n * Uses Map for O(1) lookups and spatial indexing concepts for date queries\n * Now with performance optimizations for large datasets\n */\nexport class EventStore {\n  constructor(config = {}) {\n    // Primary storage - Map for O(1) ID lookups\n    /** @type {Map<string, Event>} */\n    this.events = new Map();\n\n    // Indices for efficient queries (using UTC for consistent indexing)\n    this.indices = {\n      /** @type {Map<string, Set<string>>} UTC Date string -> Set of event IDs */\n      byDate: new Map(),\n      /** @type {Map<string, Set<string>>} YYYY-MM (UTC) -> Set of event IDs */\n      byMonth: new Map(),\n      /** @type {Set<string>} Set of recurring event IDs */\n      recurring: new Set(),\n      /** @type {Map<string, Set<string>>} Category -> Set of event IDs */\n      byCategory: new Map(),\n      /** @type {Map<string, Set<string>>} Status -> Set of event IDs */\n      byStatus: new Map()\n    };\n\n    // Timezone manager for conversions\n    this.timezoneManager = new TimezoneManager();\n\n    // Default timezone for the store (can be overridden)\n    this.defaultTimezone = config.timezone || this.timezoneManager.getSystemTimezone();\n\n    // Performance optimizer\n    this.optimizer = new PerformanceOptimizer(config.performance);\n\n    // Conflict detector\n    this.conflictDetector = new ConflictDetector(this);\n\n    // Batch operation state\n    this.isBatchMode = false;\n    this.batchNotifications = [];\n    this.batchBackup = null; // For rollback support\n\n    // Change tracking\n    /** @type {number} */\n    this.version = 0;\n    /** @type {Set<import('../../types.js').EventListener>} */\n    this.listeners = new Set();\n  }\n\n  /**\n   * Add an event to the store\n   * @param {Event|import('../../types.js').EventData} event - The event to add\n   * @returns {Event} The added event\n   * @throws {Error} If event with same ID already exists\n   */\n  addEvent(event) {\n    return this.optimizer.measure('addEvent', () => {\n      if (!(event instanceof Event)) {\n        event = new Event(event);\n      }\n\n      if (this.events.has(event.id)) {\n        throw new Error(`Event with id ${event.id} already exists`);\n      }\n\n      // Store the event\n      this.events.set(event.id, event);\n\n      // Cache the event\n      this.optimizer.cache(event.id, event, 'event');\n\n      // Update indices\n      this._indexEvent(event);\n\n      // Notify listeners (batch if in batch mode)\n      if (this.isBatchMode) {\n        this.batchNotifications.push({\n          type: 'add',\n          event,\n          version: ++this.version\n        });\n      } else {\n        this._notifyChange({\n          type: 'add',\n          event,\n          version: ++this.version\n        });\n      }\n\n      return event;\n    });\n  }\n\n  /**\n   * Update an existing event\n   * @param {string} eventId - The event ID\n   * @param {Partial<import('../../types.js').EventData>} updates - Properties to update\n   * @returns {Event} The updated event\n   * @throws {Error} If event not found\n   */\n  updateEvent(eventId, updates) {\n    const existingEvent = this.events.get(eventId);\n    if (!existingEvent) {\n      throw new Error(`Event with id ${eventId} not found`);\n    }\n\n    // Remove old indices\n    this._unindexEvent(existingEvent);\n\n    // Create updated event\n    const updatedEvent = existingEvent.clone(updates);\n\n    // Store updated event\n    this.events.set(eventId, updatedEvent);\n\n    // Re-index\n    this._indexEvent(updatedEvent);\n\n    // Notify listeners\n    this._notifyChange({\n      type: 'update',\n      event: updatedEvent,\n      oldEvent: existingEvent,\n      version: ++this.version\n    });\n\n    return updatedEvent;\n  }\n\n  /**\n   * Remove an event from the store\n   * @param {string} eventId - The event ID to remove\n   * @returns {boolean} True if removed, false if not found\n   */\n  removeEvent(eventId) {\n    const event = this.events.get(eventId);\n    if (!event) {\n      return false;\n    }\n\n    // Remove from primary storage\n    this.events.delete(eventId);\n\n    // Remove from indices\n    this._unindexEvent(event);\n\n    // Notify listeners\n    this._notifyChange({\n      type: 'remove',\n      event,\n      version: ++this.version\n    });\n\n    return true;\n  }\n\n  /**\n   * Get an event by ID\n   * @param {string} eventId - The event ID\n   * @returns {Event|null} The event or null if not found\n   */\n  getEvent(eventId) {\n    // Check cache first\n    const cached = this.optimizer.getFromCache(eventId, 'event');\n    if (cached) {\n      return cached;\n    }\n\n    // Get from store\n    const event = this.events.get(eventId) || null;\n\n    // Cache if found\n    if (event) {\n      this.optimizer.cache(eventId, event, 'event');\n    }\n\n    return event;\n  }\n\n  /**\n   * Get all events\n   * @returns {Event[]} Array of all events\n   */\n  getAllEvents() {\n    return Array.from(this.events.values());\n  }\n\n  /**\n   * Query events with filters\n   * @param {import('../../types.js').QueryFilters} [filters={}] - Query filters\n   * @returns {Event[]} Filtered events\n   */\n  queryEvents(filters = {}) {\n    let results = Array.from(this.events.values());\n\n    // Filter by date range\n    if (filters.start || filters.end) {\n      const start = filters.start ? new Date(filters.start) : null;\n      const end = filters.end ? new Date(filters.end) : null;\n\n      results = results.filter(event => {\n        if (start && event.end < start) return false;\n        if (end && event.start > end) return false;\n        return true;\n      });\n    }\n\n    // Filter by specific date\n    if (filters.date) {\n      const date = new Date(filters.date);\n      results = results.filter(event => event.occursOn(date));\n    }\n\n    // Filter by month\n    if (filters.month && filters.year) {\n      const monthKey = `${filters.year}-${String(filters.month).padStart(2, '0')}`;\n      const eventIds = this.indices.byMonth.get(monthKey) || new Set();\n      results = results.filter(event => eventIds.has(event.id));\n    }\n\n    // Filter by all-day events\n    if (filters.hasOwnProperty('allDay')) {\n      results = results.filter(event => event.allDay === filters.allDay);\n    }\n\n    // Filter by recurring\n    if (filters.hasOwnProperty('recurring')) {\n      results = results.filter(event => event.recurring === filters.recurring);\n    }\n\n    // Filter by status\n    if (filters.status) {\n      results = results.filter(event => event.status === filters.status);\n    }\n\n    // Filter by categories\n    if (filters.categories && filters.categories.length > 0) {\n      results = results.filter(event =>\n        filters.matchAllCategories\n          ? event.hasAllCategories(filters.categories)\n          : event.hasAnyCategory(filters.categories)\n      );\n    }\n\n    // Filter by having attendees\n    if (filters.hasOwnProperty('hasAttendees')) {\n      results = results.filter(event => filters.hasAttendees ? event.hasAttendees : !event.hasAttendees);\n    }\n\n    // Filter by organizer email\n    if (filters.organizerEmail) {\n      results = results.filter(event =>\n        event.organizer && event.organizer.email === filters.organizerEmail\n      );\n    }\n\n    // Sort results\n    if (filters.sort) {\n      results.sort((a, b) => {\n        switch (filters.sort) {\n          case 'start':\n            return a.start - b.start;\n          case 'end':\n            return a.end - b.end;\n          case 'duration':\n            return a.duration - b.duration;\n          case 'title':\n            return a.title.localeCompare(b.title);\n          default:\n            return 0;\n        }\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Get events for a specific date\n   * @param {Date} date - The date to query\n   * @param {string} [timezone] - Timezone for the query (defaults to store timezone)\n   * @returns {Event[]} Events occurring on the date, sorted by start time\n   */\n  getEventsForDate(date, timezone = null) {\n    timezone = timezone || this.defaultTimezone;\n\n    // Use local date string for the query date (in the calendar's timezone)\n    const dateStr = DateUtils.getLocalDateString(date);\n\n    // Get all events indexed for this date\n    const allEvents = [];\n\n    // Since events might span multiple days in different timezones,\n    // we need to check events from surrounding dates too\n    const checkDate = new Date(date);\n    for (let offset = -1; offset <= 1; offset++) {\n      const tempDate = new Date(checkDate);\n      tempDate.setDate(tempDate.getDate() + offset);\n      const tempDateStr = DateUtils.getLocalDateString(tempDate);\n      const eventIds = this.indices.byDate.get(tempDateStr) || new Set();\n\n      for (const id of eventIds) {\n        const event = this.events.get(id);\n        if (event && !allEvents.find(e => e.id === event.id)) {\n          // Check if event actually occurs on the requested date in the given timezone\n          const eventStartLocal = event.getStartInTimezone(timezone);\n          const eventEndLocal = event.getEndInTimezone(timezone);\n\n          const startOfDay = new Date(date);\n          startOfDay.setHours(0, 0, 0, 0);\n          const endOfDay = new Date(date);\n          endOfDay.setHours(23, 59, 59, 999);\n\n          // Event overlaps with this day if it starts before end of day and ends after start of day\n          if (eventStartLocal <= endOfDay && eventEndLocal >= startOfDay) {\n            allEvents.push(event);\n          }\n        }\n      }\n    }\n\n    return allEvents.sort((a, b) => {\n      // Sort by start time in the specified timezone\n      const aStart = a.getStartInTimezone(timezone);\n      const bStart = b.getStartInTimezone(timezone);\n      const timeCompare = aStart - bStart;\n      if (timeCompare !== 0) return timeCompare;\n      return b.duration - a.duration; // Longer events first\n    });\n  }\n\n  /**\n   * Get events that overlap with a given time range\n   * @param {Date} start - Start time\n   * @param {Date} end - End time\n   * @param {string} [excludeId=null] - Optional event ID to exclude (useful when checking for conflicts)\n   * @returns {Event[]} Array of overlapping events\n   */\n  getOverlappingEvents(start, end, excludeId = null) {\n    const overlapping = [];\n\n    // Get all events in the date range\n    const startDate = DateUtils.startOfDay(start);\n    const endDate = DateUtils.endOfDay(end);\n    const dates = DateUtils.getDateRange(startDate, endDate);\n\n    // Collect all events from those dates\n    const checkedIds = new Set();\n    dates.forEach(date => {\n      const dateStr = date.toDateString();\n      const eventIds = this.indices.byDate.get(dateStr) || new Set();\n\n      eventIds.forEach(id => {\n        if (!checkedIds.has(id) && id !== excludeId) {\n          checkedIds.add(id);\n          const event = this.events.get(id);\n\n          if (event && event.overlaps({ start, end })) {\n            overlapping.push(event);\n          }\n        }\n      });\n    });\n\n    return overlapping.sort((a, b) => a.start - b.start);\n  }\n\n  /**\n   * Check if an event would conflict with existing events\n   * @param {Date} start - Start time\n   * @param {Date} end - End time\n   * @param {string} excludeId - Optional event ID to exclude\n   * @returns {boolean} True if there are conflicts\n   */\n  hasConflicts(start, end, excludeId = null) {\n    return this.getOverlappingEvents(start, end, excludeId).length > 0;\n  }\n\n  /**\n   * Get events grouped by overlapping time slots\n   * Useful for calculating event positions in week/day views\n   * @param {Date} date - The date to analyze\n   * @param {boolean} timedOnly - Only include timed events (not all-day)\n   * @returns {Array<Event[]>} Array of event groups that overlap\n   */\n  getOverlapGroups(date, timedOnly = true) {\n    let events = this.getEventsForDate(date);\n\n    if (timedOnly) {\n      events = events.filter(e => !e.allDay);\n    }\n\n    const groups = [];\n    const processed = new Set();\n\n    events.forEach(event => {\n      if (processed.has(event.id)) return;\n\n      // Start a new group with this event\n      const group = [event];\n      processed.add(event.id);\n\n      // Find all events that overlap with any event in this group\n      let i = 0;\n      while (i < group.length) {\n        const currentEvent = group[i];\n\n        events.forEach(otherEvent => {\n          if (!processed.has(otherEvent.id) && currentEvent.overlaps(otherEvent)) {\n            group.push(otherEvent);\n            processed.add(otherEvent.id);\n          }\n        });\n\n        i++;\n      }\n\n      groups.push(group);\n    });\n\n    return groups;\n  }\n\n  /**\n   * Calculate positions for overlapping events (for rendering)\n   * @param {Event[]} events - Array of overlapping events\n   * @returns {Map<string, {column: number, totalColumns: number}>} Position data for each event\n   */\n  calculateEventPositions(events) {\n    const positions = new Map();\n\n    if (events.length === 0) return positions;\n\n    // Sort by start time, then by duration (longer events first)\n    events.sort((a, b) => {\n      const startDiff = a.start - b.start;\n      if (startDiff !== 0) return startDiff;\n      return (b.end - b.start) - (a.end - a.start);\n    });\n\n    // Track which columns are occupied at each time\n    const columns = [];\n\n    events.forEach(event => {\n      // Find the first available column\n      let column = 0;\n      while (column < columns.length) {\n        const columnEvents = columns[column];\n        const hasConflict = columnEvents.some(e => e.overlaps(event));\n\n        if (!hasConflict) {\n          break;\n        }\n        column++;\n      }\n\n      // Add event to the column\n      if (!columns[column]) {\n        columns[column] = [];\n      }\n      columns[column].push(event);\n\n      positions.set(event.id, {\n        column: column,\n        totalColumns: 0 // Will be updated after all events are placed\n      });\n    });\n\n    // Update total columns for all events\n    const totalColumns = columns.length;\n    positions.forEach(pos => {\n      pos.totalColumns = totalColumns;\n    });\n\n    return positions;\n  }\n\n  /**\n   * Get events for a date range\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {boolean|string} expandRecurring - Whether to expand recurring events, or timezone string\n   * @param {string} [timezone] - Timezone for the query (if expandRecurring is boolean)\n   * @returns {Event[]}\n   */\n  getEventsInRange(start, end, expandRecurring = true, timezone = null) {\n    // Handle overloaded parameters\n    if (typeof expandRecurring === 'string') {\n      timezone = expandRecurring;\n      expandRecurring = true;\n    }\n\n    timezone = timezone || this.defaultTimezone;\n\n    // Convert range to UTC for querying\n    const startUTC = this.timezoneManager.toUTC(start, timezone);\n    const endUTC = this.timezoneManager.toUTC(end, timezone);\n\n    // Query using UTC times\n    const baseEvents = this.queryEvents({\n      start: startUTC,\n      end: endUTC,\n      sort: 'start'\n    });\n\n    if (!expandRecurring) {\n      return baseEvents;\n    }\n\n    // Expand recurring events\n    const expandedEvents = [];\n    baseEvents.forEach(event => {\n      if (event.recurring && event.recurrenceRule) {\n        const occurrences = this.expandRecurringEvent(event, start, end, timezone);\n        expandedEvents.push(...occurrences);\n      } else {\n        expandedEvents.push(event);\n      }\n    });\n\n    return expandedEvents.sort((a, b) => {\n      // Sort by start time in the specified timezone\n      const aStart = a.getStartInTimezone(timezone);\n      const bStart = b.getStartInTimezone(timezone);\n      return aStart - bStart;\n    });\n  }\n\n  /**\n   * Expand a recurring event into individual occurrences\n   * @param {Event} event - The recurring event\n   * @param {Date} rangeStart - Start of the expansion range\n   * @param {Date} rangeEnd - End of the expansion range\n   * @param {string} [timezone] - Timezone for the expansion\n   * @returns {Event[]} Array of event occurrences\n   */\n  expandRecurringEvent(event, rangeStart, rangeEnd, timezone = null) {\n    if (!event.recurring || !event.recurrenceRule) {\n      return [event];\n    }\n\n    timezone = timezone || this.defaultTimezone;\n\n    // Expand in the event's timezone for accurate recurrence calculation\n    const eventTimezone = event.timeZone || timezone;\n    const occurrences = RecurrenceEngine.expandEvent(event, rangeStart, rangeEnd);\n\n    return occurrences.map((occurrence, index) => {\n      // Create a new event instance for each occurrence\n      const occurrenceEvent = event.clone({\n        id: `${event.id}_occurrence_${index}`,\n        start: occurrence.start,\n        end: occurrence.end,\n        timeZone: eventTimezone,\n        metadata: {\n          ...event.metadata,\n          recurringEventId: event.id,\n          occurrenceIndex: index\n        }\n      });\n\n      return occurrenceEvent;\n    });\n  }\n\n  /**\n   * Clear all events\n   */\n  clear() {\n    const oldEvents = this.getAllEvents();\n\n    this.events.clear();\n    this.indices.byDate.clear();\n    this.indices.byMonth.clear();\n    this.indices.recurring.clear();\n\n    this._notifyChange({\n      type: 'clear',\n      oldEvents,\n      version: ++this.version\n    });\n  }\n\n  /**\n   * Bulk load events\n   * @param {Event[]} events - Array of events or event data\n   */\n  loadEvents(events) {\n    this.clear();\n\n    for (const eventData of events) {\n      this.addEvent(eventData);\n    }\n  }\n\n  /**\n   * Subscribe to store changes\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(callback) {\n    this.listeners.add(callback);\n\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n\n  /**\n   * Index an event for efficient queries\n   * @private\n   */\n  _indexEvent(event) {\n    // Check if should use lazy indexing for large date ranges\n    if (this.optimizer.shouldUseLazyIndexing(event)) {\n      this._indexEventLazy(event);\n      return;\n    }\n\n    // Index by local dates in the event's timezone\n    // This ensures events appear on the correct calendar day\n    const eventStartLocal = event.getStartInTimezone(event.timeZone);\n    const eventEndLocal = event.getEndInTimezone(event.endTimeZone || event.timeZone);\n\n    const startDate = DateUtils.startOfDay(eventStartLocal);\n    const endDate = DateUtils.endOfDay(eventEndLocal);\n\n    // For each day the event spans (in local time), add to date index\n    const dates = DateUtils.getDateRange(startDate, endDate);\n\n    dates.forEach(date => {\n      const dateStr = DateUtils.getLocalDateString(date);\n\n      if (!this.indices.byDate.has(dateStr)) {\n        this.indices.byDate.set(dateStr, new Set());\n      }\n      this.indices.byDate.get(dateStr).add(event.id);\n    });\n\n    // Index by month(s) using UTC\n    const startMonth = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}`;\n    const endMonth = `${endDate.getFullYear()}-${String(endDate.getMonth() + 1).padStart(2, '0')}`;\n\n    // Add to all months the event spans\n    const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);\n    while (currentMonth <= endDate) {\n      const monthKey = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;\n\n      if (!this.indices.byMonth.has(monthKey)) {\n        this.indices.byMonth.set(monthKey, new Set());\n      }\n      this.indices.byMonth.get(monthKey).add(event.id);\n\n      currentMonth.setMonth(currentMonth.getMonth() + 1);\n    }\n\n    // Index by categories\n    if (event.categories && event.categories.length > 0) {\n      event.categories.forEach(category => {\n        if (!this.indices.byCategory.has(category)) {\n          this.indices.byCategory.set(category, new Set());\n        }\n        this.indices.byCategory.get(category).add(event.id);\n      });\n    }\n\n    // Index by status\n    if (event.status) {\n      if (!this.indices.byStatus.has(event.status)) {\n        this.indices.byStatus.set(event.status, new Set());\n      }\n      this.indices.byStatus.get(event.status).add(event.id);\n    }\n\n    // Index recurring events\n    if (event.recurring) {\n      this.indices.recurring.add(event.id);\n    }\n  }\n\n  /**\n   * Lazy index for events with large date ranges\n   * @private\n   */\n  _indexEventLazy(event) {\n    // Create lazy index markers\n    const markers = this.optimizer.createLazyIndexMarkers(event);\n\n    // Index only the boundaries initially (in event's local timezone)\n    const eventStartLocal = event.getStartInTimezone(event.timeZone);\n    const eventEndLocal = event.getEndInTimezone(event.endTimeZone || event.timeZone);\n\n    const startDate = DateUtils.startOfDay(eventStartLocal);\n    const endDate = DateUtils.endOfDay(eventEndLocal);\n\n    // Index first week\n    const firstWeekEnd = new Date(startDate);\n    firstWeekEnd.setDate(firstWeekEnd.getDate() + 7);\n    const firstWeekDates = DateUtils.getDateRange(startDate,\n      firstWeekEnd < endDate ? firstWeekEnd : endDate);\n\n    firstWeekDates.forEach(date => {\n      const dateStr = DateUtils.getLocalDateString(date);\n      if (!this.indices.byDate.has(dateStr)) {\n        this.indices.byDate.set(dateStr, new Set());\n      }\n      this.indices.byDate.get(dateStr).add(event.id);\n    });\n\n    // Index last week if different from first\n    if (endDate > firstWeekEnd) {\n      const lastWeekStart = new Date(endDate);\n      lastWeekStart.setDate(lastWeekStart.getDate() - 7);\n      const lastWeekDates = DateUtils.getDateRange(\n        lastWeekStart > startDate ? lastWeekStart : startDate,\n        endDate\n      );\n\n      lastWeekDates.forEach(date => {\n        const dateStr = DateUtils.getLocalDateString(date);\n        if (!this.indices.byDate.has(dateStr)) {\n          this.indices.byDate.set(dateStr, new Set());\n        }\n        this.indices.byDate.get(dateStr).add(event.id);\n      });\n    }\n\n    // Index months as normal\n    const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);\n    while (currentMonth <= endDate) {\n      const monthKey = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;\n      if (!this.indices.byMonth.has(monthKey)) {\n        this.indices.byMonth.set(monthKey, new Set());\n      }\n      this.indices.byMonth.get(monthKey).add(event.id);\n      currentMonth.setMonth(currentMonth.getMonth() + 1);\n    }\n\n    // Index other properties normally\n    if (event.categories && event.categories.length > 0) {\n      event.categories.forEach(category => {\n        if (!this.indices.byCategory.has(category)) {\n          this.indices.byCategory.set(category, new Set());\n        }\n        this.indices.byCategory.get(category).add(event.id);\n      });\n    }\n\n    if (event.status) {\n      if (!this.indices.byStatus.has(event.status)) {\n        this.indices.byStatus.set(event.status, new Set());\n      }\n      this.indices.byStatus.get(event.status).add(event.id);\n    }\n\n    if (event.recurring) {\n      this.indices.recurring.add(event.id);\n    }\n  }\n\n  /**\n   * Remove event from indices\n   * @private\n   */\n  _unindexEvent(event) {\n    // Remove from date indices\n    for (const [dateStr, eventIds] of this.indices.byDate) {\n      eventIds.delete(event.id);\n      if (eventIds.size === 0) {\n        this.indices.byDate.delete(dateStr);\n      }\n    }\n\n    // Remove from month indices\n    for (const [monthKey, eventIds] of this.indices.byMonth) {\n      eventIds.delete(event.id);\n      if (eventIds.size === 0) {\n        this.indices.byMonth.delete(monthKey);\n      }\n    }\n\n    // Remove from recurring index\n    this.indices.recurring.delete(event.id);\n  }\n\n  /**\n   * Notify listeners of changes\n   * @private\n   */\n  _notifyChange(change) {\n    for (const listener of this.listeners) {\n      try {\n        listener(change);\n      } catch (error) {\n        console.error('Error in EventStore listener:', error);\n      }\n    }\n  }\n\n  /**\n   * Get store statistics\n   * @returns {Object}\n   */\n  getStats() {\n    return {\n      totalEvents: this.events.size,\n      recurringEvents: this.indices.recurring.size,\n      indexedDates: this.indices.byDate.size,\n      indexedMonths: this.indices.byMonth.size,\n      indexedCategories: this.indices.byCategory.size,\n      indexedStatuses: this.indices.byStatus.size,\n      version: this.version,\n      performanceMetrics: this.optimizer.getMetrics()\n    };\n  }\n\n  // ============ Batch Operations ============\n\n  /**\n   * Start batch mode for bulk operations\n   * Delays notifications until batch is committed\n   * @param {boolean} [enableRollback=false] - Enable rollback support (creates backup)\n   */\n  startBatch(enableRollback = false) {\n    this.isBatchMode = true;\n    this.batchNotifications = [];\n\n    // Create backup for rollback if requested\n    if (enableRollback) {\n      this.batchBackup = {\n        events: new Map(this.events),\n        indices: {\n          byDate: new Map(Array.from(this.indices.byDate.entries()).map(([k, v]) => [k, new Set(v)])),\n          byMonth: new Map(Array.from(this.indices.byMonth.entries()).map(([k, v]) => [k, new Set(v)])),\n          recurring: new Set(this.indices.recurring),\n          byCategory: new Map(Array.from(this.indices.byCategory.entries()).map(([k, v]) => [k, new Set(v)])),\n          byStatus: new Map(Array.from(this.indices.byStatus.entries()).map(([k, v]) => [k, new Set(v)]))\n        },\n        version: this.version\n      };\n    }\n  }\n\n  /**\n   * Commit batch operations\n   * Sends all notifications at once\n   */\n  commitBatch() {\n    if (!this.isBatchMode) return;\n\n    this.isBatchMode = false;\n\n    // Clear backup after successful commit\n    this.batchBackup = null;\n\n    // Send a single bulk notification\n    if (this.batchNotifications.length > 0) {\n      this._notifyChange({\n        type: 'batch',\n        changes: this.batchNotifications,\n        count: this.batchNotifications.length,\n        version: ++this.version\n      });\n    }\n\n    this.batchNotifications = [];\n  }\n\n  /**\n   * Rollback batch operations\n   * Restores state to before batch started\n   */\n  rollbackBatch() {\n    if (!this.isBatchMode) return;\n\n    this.isBatchMode = false;\n\n    // Restore backup if available\n    if (this.batchBackup) {\n      this.events = this.batchBackup.events;\n      this.indices = this.batchBackup.indices;\n      this.version = this.batchBackup.version;\n      this.batchBackup = null;\n\n      // Clear cache\n      this.optimizer.clearCache();\n    }\n\n    this.batchNotifications = [];\n  }\n\n  /**\n   * Execute batch operation with automatic rollback on error\n   * @param {Function} operation - Operation to execute\n   * @param {boolean} [enableRollback=true] - Enable automatic rollback on error\n   * @returns {*} Result of operation\n   * @throws {Error} If operation fails\n   */\n  async executeBatch(operation, enableRollback = true) {\n    this.startBatch(enableRollback);\n\n    try {\n      const result = await operation();\n      this.commitBatch();\n      return result;\n    } catch (error) {\n      if (enableRollback) {\n        this.rollbackBatch();\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Add multiple events in batch\n   * @param {Array<Event|import('../../types.js').EventData>} events - Events to add\n   * @returns {Event[]} Added events\n   */\n  addEvents(events) {\n    return this.optimizer.measure('addEvents', () => {\n      this.startBatch();\n      const results = [];\n      const errors = [];\n\n      for (const eventData of events) {\n        try {\n          results.push(this.addEvent(eventData));\n        } catch (error) {\n          errors.push({ event: eventData, error: error.message });\n        }\n      }\n\n      this.commitBatch();\n\n      if (errors.length > 0) {\n        console.warn(`Failed to add ${errors.length} events:`, errors);\n      }\n\n      return results;\n    });\n  }\n\n  /**\n   * Update multiple events in batch\n   * @param {Array<{id: string, updates: Object}>} updates - Update operations\n   * @returns {Event[]} Updated events\n   */\n  updateEvents(updates) {\n    return this.optimizer.measure('updateEvents', () => {\n      this.startBatch();\n      const results = [];\n      const errors = [];\n\n      for (const { id, updates: eventUpdates } of updates) {\n        try {\n          results.push(this.updateEvent(id, eventUpdates));\n        } catch (error) {\n          errors.push({ id, error: error.message });\n        }\n      }\n\n      this.commitBatch();\n\n      if (errors.length > 0) {\n        console.warn(`Failed to update ${errors.length} events:`, errors);\n      }\n\n      return results;\n    });\n  }\n\n  /**\n   * Remove multiple events in batch\n   * @param {string[]} eventIds - Event IDs to remove\n   * @returns {number} Number of events removed\n   */\n  removeEvents(eventIds) {\n    return this.optimizer.measure('removeEvents', () => {\n      this.startBatch();\n      let removed = 0;\n\n      for (const id of eventIds) {\n        if (this.removeEvent(id)) {\n          removed++;\n        }\n      }\n\n      this.commitBatch();\n      return removed;\n    });\n  }\n\n  // ============ Performance Methods ============\n\n  /**\n   * Get performance metrics\n   * @returns {Object} Performance metrics\n   */\n  getPerformanceMetrics() {\n    return this.optimizer.getMetrics();\n  }\n\n  /**\n   * Clear all caches\n   */\n  clearCaches() {\n    this.optimizer.eventCache.clear();\n    this.optimizer.queryCache.clear();\n    this.optimizer.dateRangeCache.clear();\n  }\n\n  /**\n   * Optimize indices by removing old or irrelevant entries\n   * @param {Date} [cutoffDate] - Remove indices older than this date\n   */\n  optimizeIndices(cutoffDate) {\n    if (!cutoffDate) {\n      cutoffDate = new Date();\n      cutoffDate.setMonth(cutoffDate.getMonth() - 6); // Default: 6 months ago\n    }\n\n    const cutoffStr = cutoffDate.toDateString();\n    let removed = 0;\n\n    // Clean up date indices\n    for (const [dateStr, eventIds] of this.indices.byDate) {\n      const date = new Date(dateStr);\n      if (date < cutoffDate) {\n        // Check if any events still need this index\n        let stillNeeded = false;\n        for (const eventId of eventIds) {\n          const event = this.events.get(eventId);\n          if (event && event.end >= cutoffDate) {\n            stillNeeded = true;\n            break;\n          }\n        }\n\n        if (!stillNeeded) {\n          this.indices.byDate.delete(dateStr);\n          removed++;\n        }\n      }\n    }\n\n    console.log(`Optimized indices: removed ${removed} old date entries`);\n    return removed;\n  }\n\n  /**\n   * Destroy the store and clean up resources\n   */\n  destroy() {\n    this.clear();\n    this.optimizer.destroy();\n    this.listeners.clear();\n  }\n\n  // ============ Conflict Detection Methods ============\n\n  /**\n   * Check for conflicts for an event\n   * @param {Event|import('../../types.js').EventData} event - Event to check\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictSummary} Conflict summary\n   */\n  checkConflicts(event, options = {}) {\n    return this.conflictDetector.checkConflicts(event, options);\n  }\n\n  /**\n   * Check conflicts between two events\n   * @param {string} eventId1 - First event ID\n   * @param {string} eventId2 - Second event ID\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictDetails[]} Conflicts between events\n   */\n  checkEventPairConflicts(eventId1, eventId2, options = {}) {\n    const event1 = this.getEvent(eventId1);\n    const event2 = this.getEvent(eventId2);\n\n    if (!event1 || !event2) {\n      throw new Error('One or both events not found');\n    }\n\n    return this.conflictDetector.checkEventPairConflicts(event1, event2, options);\n  }\n\n  /**\n   * Get all conflicts in a date range\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictSummary} All conflicts in range\n   */\n  getAllConflicts(start, end, options = {}) {\n    const events = this.getEventsInRange(start, end, false);\n    const allConflicts = [];\n    const checkedPairs = new Set();\n\n    for (let i = 0; i < events.length; i++) {\n      for (let j = i + 1; j < events.length; j++) {\n        const pairKey = `${events[i].id}-${events[j].id}`;\n        if (!checkedPairs.has(pairKey)) {\n          checkedPairs.add(pairKey);\n          const conflicts = this.conflictDetector.checkEventPairConflicts(\n            events[i],\n            events[j],\n            options\n          );\n          allConflicts.push(...conflicts);\n        }\n      }\n    }\n\n    return this.conflictDetector._buildConflictSummary(\n      allConflicts,\n      new Set(events.map(e => e.id)),\n      new Set()\n    );\n  }\n\n  /**\n   * Get busy periods for attendees\n   * @param {string[]} attendeeEmails - Attendee emails\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date, eventIds: string[]}>} Busy periods\n   */\n  getBusyPeriods(attendeeEmails, start, end, options = {}) {\n    return this.conflictDetector.getBusyPeriods(attendeeEmails, start, end, options);\n  }\n\n  /**\n   * Get free periods for scheduling\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {number} durationMinutes - Required duration in minutes\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date}>} Free periods\n   */\n  getFreePeriods(start, end, durationMinutes, options = {}) {\n    return this.conflictDetector.getFreePeriods(start, end, durationMinutes, options);\n  }\n\n  /**\n   * Add event with conflict checking\n   * @param {Event|import('../../types.js').EventData} event - Event to add\n   * @param {boolean} [allowConflicts=true] - Whether to allow adding with conflicts\n   * @returns {{event: Event, conflicts: import('../../types.js').ConflictSummary}} Result\n   */\n  addEventWithConflictCheck(event, allowConflicts = true) {\n    // Check conflicts before adding\n    const conflicts = this.checkConflicts(event);\n\n    if (!allowConflicts && conflicts.hasConflicts) {\n      throw new Error(`Cannot add event: ${conflicts.totalConflicts} conflicts detected`);\n    }\n\n    // Add the event\n    const addedEvent = this.addEvent(event);\n\n    return {\n      event: addedEvent,\n      conflicts\n    };\n  }\n\n  /**\n   * Find events with conflicts\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{event: Event, conflicts: import('../../types.js').ConflictDetails[]}>} Events with conflicts\n   */\n  findEventsWithConflicts(options = {}) {\n    const eventsWithConflicts = [];\n    const allEvents = this.getAllEvents();\n\n    for (const event of allEvents) {\n      const conflicts = this.checkConflicts(event, options);\n      if (conflicts.hasConflicts) {\n        eventsWithConflicts.push({\n          event,\n          conflicts: conflicts.conflicts\n        });\n      }\n    }\n\n    return eventsWithConflicts;\n  }\n}","/**\n * StateManager - Central state management for the calendar\n * Implements an immutable state pattern with change notifications\n */\nexport class StateManager {\n  /**\n   * Create a new StateManager instance\n   * @param {Partial<import('../../types.js').CalendarState>} [initialState={}] - Initial state values\n   */\n  constructor(initialState = {}) {\n    this.state = {\n      // Current view configuration\n      view: 'month', // 'month', 'week', 'day', 'list'\n      currentDate: new Date(),\n\n      // UI state\n      selectedEventId: null,\n      selectedDate: null,\n      hoveredEventId: null,\n      hoveredDate: null,\n\n      // Display options\n      weekStartsOn: 0, // 0 = Sunday, 1 = Monday, etc.\n      showWeekNumbers: false,\n      showWeekends: true,\n      fixedWeekCount: true, // Always show 6 weeks in month view\n\n      // Time configuration\n      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      locale: 'en-US',\n      hourFormat: '12h', // '12h' or '24h'\n\n      // Business hours (for week/day views)\n      businessHours: {\n        start: '09:00',\n        end: '17:00'\n      },\n\n      // Filters\n      filters: {\n        searchTerm: '',\n        categories: [],\n        showAllDay: true,\n        showTimed: true\n      },\n\n      // Interaction flags\n      isDragging: false,\n      isResizing: false,\n      isCreating: false,\n\n      // Loading states\n      isLoading: false,\n      loadingMessage: '',\n\n      // Error state\n      error: null,\n\n      // Custom metadata\n      metadata: {},\n\n      // Apply initial state overrides\n      ...initialState\n    };\n\n    // Observers for state changes\n    this.listeners = new Map();\n    this.globalListeners = new Set();\n\n    // History for undo/redo (optional)\n    this.history = [];\n    this.historyIndex = -1;\n    this.maxHistorySize = 50;\n  }\n\n  /**\n   * Get the current state\n   * @returns {import('../../types.js').CalendarState} Current state (frozen)\n   */\n  getState() {\n    return Object.freeze({ ...this.state });\n  }\n\n  /**\n   * Get a specific state value\n   * @param {keyof import('../../types.js').CalendarState} key - The state key\n   * @returns {any} The state value\n   */\n  get(key) {\n    return this.state[key];\n  }\n\n  /**\n   * Update state with partial updates\n   * @param {Object|Function} updates - Object with updates or updater function\n   */\n  setState(updates) {\n    const oldState = this.state;\n\n    // Support function updater pattern\n    if (typeof updates === 'function') {\n      updates = updates(oldState);\n    }\n\n    // Create new state with updates\n    const newState = {\n      ...oldState,\n      ...updates,\n      // Preserve nested objects\n      filters: updates.filters ? { ...oldState.filters, ...updates.filters } : oldState.filters,\n      businessHours: updates.businessHours ? { ...oldState.businessHours, ...updates.businessHours } : oldState.businessHours,\n      metadata: updates.metadata ? { ...oldState.metadata, ...updates.metadata } : oldState.metadata\n    };\n\n    // Check if state actually changed\n    if (this._hasChanged(oldState, newState)) {\n      this.state = newState;\n\n      // Add to history (store the new state)\n      this._addToHistory(newState);\n\n      // Notify listeners\n      this._notifyListeners(oldState, newState);\n    }\n  }\n\n  /**\n   * Set the current view\n   * @param {string} view - The view type\n   */\n  setView(view) {\n    const validViews = ['month', 'week', 'day', 'list'];\n    if (!validViews.includes(view)) {\n      throw new Error(`Invalid view: ${view}. Must be one of: ${validViews.join(', ')}`);\n    }\n    this.setState({ view });\n  }\n\n  /**\n   * Set the current date\n   * @param {Date} date - The date to set\n   */\n  setCurrentDate(date) {\n    if (!(date instanceof Date)) {\n      date = new Date(date);\n    }\n    if (isNaN(date.getTime())) {\n      throw new Error('Invalid date');\n    }\n    this.setState({ currentDate: date });\n  }\n\n  /**\n   * Navigate to the next period (month/week/day based on view)\n   */\n  navigateNext() {\n    const { view, currentDate } = this.state;\n    const newDate = new Date(currentDate);\n\n    switch (view) {\n      case 'month':\n        newDate.setMonth(newDate.getMonth() + 1);\n        break;\n      case 'week':\n        newDate.setDate(newDate.getDate() + 7);\n        break;\n      case 'day':\n        newDate.setDate(newDate.getDate() + 1);\n        break;\n    }\n\n    this.setCurrentDate(newDate);\n  }\n\n  /**\n   * Navigate to the previous period\n   */\n  navigatePrevious() {\n    const { view, currentDate } = this.state;\n    const newDate = new Date(currentDate);\n\n    switch (view) {\n      case 'month':\n        newDate.setMonth(newDate.getMonth() - 1);\n        break;\n      case 'week':\n        newDate.setDate(newDate.getDate() - 7);\n        break;\n      case 'day':\n        newDate.setDate(newDate.getDate() - 1);\n        break;\n    }\n\n    this.setCurrentDate(newDate);\n  }\n\n  /**\n   * Navigate to today\n   */\n  navigateToday() {\n    this.setCurrentDate(new Date());\n  }\n\n  /**\n   * Select an event\n   * @param {string} eventId - The event ID to select\n   */\n  selectEvent(eventId) {\n    this.setState({ selectedEventId: eventId });\n  }\n\n  /**\n   * Clear event selection\n   */\n  clearEventSelection() {\n    this.setState({ selectedEventId: null });\n  }\n\n  /**\n   * Select a date\n   * @param {Date} date - The date to select\n   */\n  selectDate(date) {\n    if (!(date instanceof Date)) {\n      date = new Date(date);\n    }\n    this.setState({ selectedDate: date });\n  }\n\n  /**\n   * Clear date selection\n   */\n  clearDateSelection() {\n    this.setState({ selectedDate: null });\n  }\n\n  /**\n   * Set loading state\n   * @param {boolean} isLoading - Loading state\n   * @param {string} message - Optional loading message\n   */\n  setLoading(isLoading, message = '') {\n    this.setState({\n      isLoading,\n      loadingMessage: message\n    });\n  }\n\n  /**\n   * Set error state\n   * @param {Error|string|null} error - The error\n   */\n  setError(error) {\n    this.setState({\n      error: error ? (error instanceof Error ? error.message : error) : null\n    });\n  }\n\n  /**\n   * Update filters\n   * @param {Object} filters - Filter updates\n   */\n  updateFilters(filters) {\n    this.setState({\n      filters: {\n        ...this.state.filters,\n        ...filters\n      }\n    });\n  }\n\n  /**\n   * Subscribe to all state changes\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(callback) {\n    this.globalListeners.add(callback);\n\n    return () => {\n      this.globalListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Subscribe to specific state key changes\n   * @param {string|string[]} keys - State key(s) to watch\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  watch(keys, callback) {\n    const keyArray = Array.isArray(keys) ? keys : [keys];\n\n    keyArray.forEach(key => {\n      if (!this.listeners.has(key)) {\n        this.listeners.set(key, new Set());\n      }\n      this.listeners.get(key).add(callback);\n    });\n\n    return () => {\n      keyArray.forEach(key => {\n        const callbacks = this.listeners.get(key);\n        if (callbacks) {\n          callbacks.delete(callback);\n          if (callbacks.size === 0) {\n            this.listeners.delete(key);\n          }\n        }\n      });\n    };\n  }\n\n  /**\n   * Check if undo is available\n   * @returns {boolean} True if undo is available\n   */\n  canUndo() {\n    return this.historyIndex > 0;\n  }\n\n  /**\n   * Check if redo is available\n   * @returns {boolean} True if redo is available\n   */\n  canRedo() {\n    return this.historyIndex < this.history.length - 1;\n  }\n\n  /**\n   * Get the number of undo operations available\n   * @returns {number} Number of undo operations\n   */\n  getUndoCount() {\n    return this.historyIndex;\n  }\n\n  /**\n   * Get the number of redo operations available\n   * @returns {number} Number of redo operations\n   */\n  getRedoCount() {\n    return this.history.length - 1 - this.historyIndex;\n  }\n\n  /**\n   * Undo the last state change\n   * @returns {boolean} True if undo was performed\n   */\n  undo() {\n    if (!this.canUndo()) {\n      return false;\n    }\n\n    this.historyIndex--;\n    const previousState = this.history[this.historyIndex];\n    const currentState = this.state;\n\n    // Update state without adding to history\n    this.state = { ...previousState };\n\n    // Notify listeners\n    this._notifyListeners(currentState, this.state);\n\n    return true;\n  }\n\n  /**\n   * Redo the next state change\n   * @returns {boolean} True if redo was performed\n   */\n  redo() {\n    if (!this.canRedo()) {\n      return false;\n    }\n\n    this.historyIndex++;\n    const nextState = this.history[this.historyIndex];\n    const currentState = this.state;\n\n    // Update state without adding to history\n    this.state = { ...nextState };\n\n    // Notify listeners\n    this._notifyListeners(currentState, this.state);\n\n    return true;\n  }\n\n  /**\n   * Reset state to initial values\n   */\n  reset() {\n    const initialState = this.history[0] || {};\n    this.setState(initialState);\n    this.history = [initialState];\n    this.historyIndex = 0;\n  }\n\n  /**\n   * Check if state has changed\n   * @private\n   */\n  _hasChanged(oldState, newState) {\n    return !this._deepEqual(oldState, newState);\n  }\n\n  /**\n   * Deep equality check optimized for state comparison\n   * @private\n   * @param {*} a - First value\n   * @param {*} b - Second value\n   * @param {Set} seen - Track circular references\n   * @returns {boolean} True if values are deeply equal\n   */\n  _deepEqual(a, b, seen = new Set()) {\n    // Same reference\n    if (a === b) return true;\n\n    // Different types or null/undefined\n    if (a == null || b == null) return a === b;\n    if (typeof a !== typeof b) return false;\n\n    // Primitives\n    if (typeof a !== 'object') return a === b;\n\n    // Check for circular references\n    if (seen.has(a) || seen.has(b)) return false;\n    seen.add(a);\n    seen.add(b);\n\n    // Arrays\n    if (Array.isArray(a)) {\n      if (!Array.isArray(b) || a.length !== b.length) {\n        seen.delete(a);\n        seen.delete(b);\n        return false;\n      }\n\n      for (let i = 0; i < a.length; i++) {\n        if (!this._deepEqual(a[i], b[i], seen)) {\n          seen.delete(a);\n          seen.delete(b);\n          return false;\n        }\n      }\n\n      seen.delete(a);\n      seen.delete(b);\n      return true;\n    }\n\n    // Dates\n    if (a instanceof Date && b instanceof Date) {\n      const result = a.getTime() === b.getTime();\n      seen.delete(a);\n      seen.delete(b);\n      return result;\n    }\n\n    // Objects\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n      seen.delete(a);\n      seen.delete(b);\n      return false;\n    }\n\n    // Sort keys for consistent comparison\n    aKeys.sort();\n    bKeys.sort();\n\n    // Compare keys\n    for (let i = 0; i < aKeys.length; i++) {\n      if (aKeys[i] !== bKeys[i]) {\n        seen.delete(a);\n        seen.delete(b);\n        return false;\n      }\n    }\n\n    // Compare values\n    for (const key of aKeys) {\n      if (!this._deepEqual(a[key], b[key], seen)) {\n        seen.delete(a);\n        seen.delete(b);\n        return false;\n      }\n    }\n\n    seen.delete(a);\n    seen.delete(b);\n    return true;\n  }\n\n  /**\n   * Add state to history\n   * @private\n   */\n  _addToHistory(state) {\n    // Remove any future history if we're not at the end\n    if (this.historyIndex < this.history.length - 1) {\n      this.history = this.history.slice(0, this.historyIndex + 1);\n    }\n\n    // Add new state\n    this.history.push({ ...state });\n    this.historyIndex++;\n\n    // Limit history size\n    if (this.history.length > this.maxHistorySize) {\n      this.history.shift();\n      this.historyIndex--;\n    }\n  }\n\n  /**\n   * Notify listeners of state changes\n   * @private\n   */\n  _notifyListeners(oldState, newState) {\n    // Notify global listeners\n    for (const callback of this.globalListeners) {\n      try {\n        callback(newState, oldState);\n      } catch (error) {\n        console.error('Error in state listener:', error);\n      }\n    }\n\n    // Notify specific key listeners\n    for (const [key, callbacks] of this.listeners) {\n      if (oldState[key] !== newState[key]) {\n        for (const callback of callbacks) {\n          try {\n            callback(newState[key], oldState[key], newState, oldState);\n          } catch (error) {\n            console.error(`Error in state listener for key \"${key}\":`, error);\n          }\n        }\n      }\n    }\n  }\n}","import { EventStore } from '../events/EventStore.js';\nimport { Event } from '../events/Event.js';\nimport { StateManager } from '../state/StateManager.js';\nimport { DateUtils } from './DateUtils.js';\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\n/**\n * Calendar - Main calendar class with full timezone support\n * Pure JavaScript, no DOM dependencies\n * Framework agnostic, Locker Service compatible\n */\nexport class Calendar {\n  /**\n   * Create a new Calendar instance\n   * @param {import('../../types.js').CalendarConfig} [config={}] - Configuration options\n   */\n  constructor(config = {}) {\n    // Initialize timezone manager first\n    this.timezoneManager = new TimezoneManager();\n\n    // Initialize configuration\n    this.config = {\n      view: 'month',\n      date: new Date(),\n      weekStartsOn: 0, // 0 = Sunday\n      locale: 'en-US',\n      timeZone: config.timeZone || this.timezoneManager.getSystemTimezone(),\n      showWeekNumbers: false,\n      showWeekends: true,\n      fixedWeekCount: true,\n      businessHours: {\n        start: '09:00',\n        end: '17:00'\n      },\n      ...config\n    };\n\n    // Initialize core components with timezone support\n    this.eventStore = new EventStore({ timezone: this.config.timeZone });\n    this.state = new StateManager({\n      view: this.config.view,\n      currentDate: this.config.date,\n      weekStartsOn: this.config.weekStartsOn,\n      locale: this.config.locale,\n      timeZone: this.config.timeZone,\n      showWeekNumbers: this.config.showWeekNumbers,\n      showWeekends: this.config.showWeekends,\n      fixedWeekCount: this.config.fixedWeekCount,\n      businessHours: this.config.businessHours\n    });\n\n    // Event emitter for calendar events\n    this.listeners = new Map();\n\n    // Plugins\n    this.plugins = new Set();\n\n    // View instances (lazy loaded)\n    this.views = new Map();\n\n    // Set up internal listeners\n    this._setupInternalListeners();\n\n    // Load initial events if provided\n    if (config.events) {\n      this.setEvents(config.events);\n    }\n  }\n\n  /**\n   * Set the calendar view\n   * @param {import('../../types.js').ViewType} viewType - The view type ('month', 'week', 'day', 'list')\n   * @param {Date} [date=null] - Optional date to navigate to\n   */\n  setView(viewType, date = null) {\n    this.state.setView(viewType);\n\n    if (date) {\n      this.state.setCurrentDate(date);\n    }\n\n    this._emit('viewChange', {\n      view: viewType,\n      date: date || this.state.get('currentDate')\n    });\n  }\n\n  /**\n   * Get the current view type\n   * @returns {import('../../types.js').ViewType} The current view type\n   */\n  getView() {\n    return this.state.get('view');\n  }\n\n  /**\n   * Navigate to the next period\n   */\n  next() {\n    this.state.navigateNext();\n    this._emit('navigate', {\n      direction: 'next',\n      date: this.state.get('currentDate'),\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Navigate to the previous period\n   */\n  previous() {\n    this.state.navigatePrevious();\n    this._emit('navigate', {\n      direction: 'previous',\n      date: this.state.get('currentDate'),\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Navigate to today\n   */\n  today() {\n    this.state.navigateToday();\n    this._emit('navigate', {\n      direction: 'today',\n      date: this.state.get('currentDate'),\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Navigate to a specific date\n   * @param {Date} date - The date to navigate to\n   */\n  goToDate(date) {\n    this.state.setCurrentDate(date);\n    this._emit('navigate', {\n      direction: 'goto',\n      date: date,\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Get the current date\n   * @returns {Date}\n   */\n  getCurrentDate() {\n    return new Date(this.state.get('currentDate'));\n  }\n\n  /**\n   * Add an event\n   * @param {import('../events/Event.js').Event|import('../../types.js').EventData} eventData - Event data or Event instance\n   * @returns {import('../events/Event.js').Event} The added event\n   */\n  addEvent(eventData) {\n    // If eventData is not an Event instance and doesn't have a timezone, use calendar's timezone\n    if (!(eventData instanceof Event) && !eventData.timeZone) {\n      eventData = { ...eventData, timeZone: this.config.timeZone };\n    }\n\n    const event = this.eventStore.addEvent(eventData);\n\n    this._emit('eventAdd', { event });\n\n    return event;\n  }\n\n  /**\n   * Update an event\n   * @param {string} eventId - The event ID\n   * @param {Object} updates - Properties to update\n   * @returns {Event} The updated event\n   */\n  updateEvent(eventId, updates) {\n    const oldEvent = this.eventStore.getEvent(eventId);\n    const event = this.eventStore.updateEvent(eventId, updates);\n\n    this._emit('eventUpdate', { event, oldEvent });\n\n    return event;\n  }\n\n  /**\n   * Remove an event\n   * @param {string} eventId - The event ID\n   * @returns {boolean} True if removed\n   */\n  removeEvent(eventId) {\n    const event = this.eventStore.getEvent(eventId);\n    const removed = this.eventStore.removeEvent(eventId);\n\n    if (removed) {\n      this._emit('eventRemove', { event });\n    }\n\n    return removed;\n  }\n\n  /**\n   * Get an event by ID\n   * @param {string} eventId - The event ID\n   * @returns {Event|null}\n   */\n  getEvent(eventId) {\n    return this.eventStore.getEvent(eventId);\n  }\n\n  /**\n   * Get all events\n   * @returns {Event[]}\n   */\n  getEvents() {\n    return this.eventStore.getAllEvents();\n  }\n\n  /**\n   * Set all events (replaces existing)\n   * @param {Event[]} events - Array of events\n   */\n  setEvents(events) {\n    this.eventStore.loadEvents(events);\n    this._emit('eventsSet', { events: this.getEvents() });\n  }\n\n  /**\n   * Query events with filters\n   * @param {Object} filters - Query filters\n   * @returns {Event[]}\n   */\n  queryEvents(filters) {\n    return this.eventStore.queryEvents(filters);\n  }\n\n  /**\n   * Get events for a specific date\n   * @param {Date} date - The date\n   * @param {string} [timezone] - Timezone for the query (defaults to calendar timezone)\n   * @returns {Event[]}\n   */\n  getEventsForDate(date, timezone = null) {\n    return this.eventStore.getEventsForDate(date, timezone || this.config.timeZone);\n  }\n\n  /**\n   * Get events in a date range\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {string} [timezone] - Timezone for the query (defaults to calendar timezone)\n   * @returns {Event[]}\n   */\n  getEventsInRange(start, end, timezone = null) {\n    return this.eventStore.getEventsInRange(start, end, true, timezone || this.config.timeZone);\n  }\n\n  /**\n   * Set the calendar's timezone\n   * @param {string} timezone - IANA timezone identifier\n   */\n  setTimezone(timezone) {\n    const parsedTimezone = this.timezoneManager.parseTimezone(timezone);\n    const previousTimezone = this.config.timeZone;\n\n    this.config.timeZone = parsedTimezone;\n    this.eventStore.defaultTimezone = parsedTimezone;\n    this.state.setState({ timeZone: parsedTimezone });\n\n    this._emit('timezoneChange', {\n      timezone: parsedTimezone,\n      previousTimezone: previousTimezone\n    });\n  }\n\n  /**\n   * Get the current timezone\n   * @returns {string} Current timezone\n   */\n  getTimezone() {\n    return this.config.timeZone;\n  }\n\n  /**\n   * Convert a date from one timezone to another\n   * @param {Date} date - Date to convert\n   * @param {string} fromTimezone - Source timezone\n   * @param {string} toTimezone - Target timezone\n   * @returns {Date} Converted date\n   */\n  convertTimezone(date, fromTimezone, toTimezone) {\n    return this.timezoneManager.convertTimezone(date, fromTimezone, toTimezone);\n  }\n\n  /**\n   * Convert a date to the calendar's timezone\n   * @param {Date} date - Date to convert\n   * @param {string} fromTimezone - Source timezone\n   * @returns {Date} Date in calendar timezone\n   */\n  toCalendarTimezone(date, fromTimezone) {\n    return this.timezoneManager.convertTimezone(date, fromTimezone, this.config.timeZone);\n  }\n\n  /**\n   * Convert a date from the calendar's timezone\n   * @param {Date} date - Date in calendar timezone\n   * @param {string} toTimezone - Target timezone\n   * @returns {Date} Converted date\n   */\n  fromCalendarTimezone(date, toTimezone) {\n    return this.timezoneManager.convertTimezone(date, this.config.timeZone, toTimezone);\n  }\n\n  /**\n   * Format a date in a specific timezone\n   * @param {Date} date - Date to format\n   * @param {string} [timezone] - Timezone for formatting (defaults to calendar timezone)\n   * @param {Object} [options] - Formatting options\n   * @returns {string} Formatted date string\n   */\n  formatInTimezone(date, timezone = null, options = {}) {\n    return this.timezoneManager.formatInTimezone(\n      date,\n      timezone || this.config.timeZone,\n      options\n    );\n  }\n\n  /**\n   * Get list of common timezones with offsets\n   * @returns {Array<{value: string, label: string, offset: string}>} Timezone list\n   */\n  getTimezones() {\n    return this.timezoneManager.getCommonTimezones();\n  }\n\n  /**\n   * Get overlapping event groups for a date\n   * @param {Date} date - The date to check\n   * @param {boolean} timedOnly - Only include timed events\n   * @returns {Array<Event[]>} Array of event groups that overlap\n   */\n  getOverlapGroups(date, timedOnly = true) {\n    return this.eventStore.getOverlapGroups(date, timedOnly);\n  }\n\n  /**\n   * Calculate event positions for rendering\n   * @param {Event[]} events - Array of overlapping events\n   * @returns {Map<string, {column: number, totalColumns: number}>} Position data\n   */\n  calculateEventPositions(events) {\n    return this.eventStore.calculateEventPositions(events);\n  }\n\n  /**\n   * Get the current view's data\n   * @returns {import('../../types.js').MonthViewData|import('../../types.js').WeekViewData|import('../../types.js').DayViewData|import('../../types.js').ListViewData|null} View-specific data\n   */\n  getViewData() {\n    const view = this.state.get('view');\n    const currentDate = this.state.get('currentDate');\n\n    switch (view) {\n      case 'month':\n        return this._getMonthViewData(currentDate);\n      case 'week':\n        return this._getWeekViewData(currentDate);\n      case 'day':\n        return this._getDayViewData(currentDate);\n      case 'list':\n        return this._getListViewData(currentDate);\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get month view data\n   * @private\n   */\n  _getMonthViewData(date) {\n    const year = date.getFullYear();\n    const month = date.getMonth();\n    const weekStartsOn = this.state.get('weekStartsOn');\n    const fixedWeekCount = this.state.get('fixedWeekCount');\n\n    // Get the first day of the month\n    const firstDay = new Date(year, month, 1);\n\n    // Get the last day of the month\n    const lastDay = new Date(year, month + 1, 0);\n\n    // Calculate the start date (beginning of the week containing the first day)\n    const startDate = DateUtils.startOfWeek(firstDay, weekStartsOn);\n\n    // Calculate weeks\n    const weeks = [];\n    let currentDate = new Date(startDate);\n\n    // Generate weeks\n    const maxWeeks = fixedWeekCount ? 6 : Math.ceil((lastDay.getDate() + DateUtils.getDayOfWeek(firstDay, weekStartsOn)) / 7);\n\n    for (let weekIndex = 0; weekIndex < maxWeeks; weekIndex++) {\n      const week = {\n        weekNumber: DateUtils.getWeekNumber(currentDate),\n        days: []\n      };\n\n      for (let dayIndex = 0; dayIndex < 7; dayIndex++) {\n        const dayDate = new Date(currentDate);\n        const isCurrentMonth = dayDate.getMonth() === month;\n        const isToday = DateUtils.isToday(dayDate);\n        const isWeekend = dayDate.getDay() === 0 || dayDate.getDay() === 6;\n\n        week.days.push({\n          date: dayDate,\n          dayOfMonth: dayDate.getDate(),\n          isCurrentMonth,\n          isToday,\n          isWeekend,\n          events: this.getEventsForDate(dayDate)\n        });\n\n        // Use DateUtils.addDays to handle month boundaries correctly\n        currentDate = DateUtils.addDays(currentDate, 1);\n      }\n\n      weeks.push(week);\n    }\n\n    return {\n      type: 'month',\n      year,\n      month,\n      monthName: DateUtils.getMonthName(date, this.state.get('locale')),\n      weeks,\n      startDate,\n      endDate: new Date(currentDate.getTime() - 1) // Last moment of the view\n    };\n  }\n\n  /**\n   * Get week view data\n   * @private\n   */\n  _getWeekViewData(date) {\n    const weekStartsOn = this.state.get('weekStartsOn');\n    const startDate = DateUtils.startOfWeek(date, weekStartsOn);\n    const endDate = DateUtils.endOfWeek(date, weekStartsOn);\n\n    const days = [];\n    const currentDate = new Date(startDate);\n\n    for (let i = 0; i < 7; i++) {\n      const dayDate = new Date(currentDate);\n      days.push({\n        date: dayDate,\n        dayOfMonth: dayDate.getDate(),\n        dayOfWeek: dayDate.getDay(),\n        dayName: DateUtils.getDayName(dayDate, this.state.get('locale')),\n        isToday: DateUtils.isToday(dayDate),\n        isWeekend: dayDate.getDay() === 0 || dayDate.getDay() === 6,\n        events: this.getEventsForDate(dayDate),\n        // Add overlap groups for positioning overlapping events\n        overlapGroups: this.eventStore.getOverlapGroups(dayDate, true),\n        getEventPositions: (events) => this.eventStore.calculateEventPositions(events)\n      });\n      // Move to next day\n      currentDate.setDate(currentDate.getDate() + 1);\n    }\n\n    return {\n      type: 'week',\n      weekNumber: DateUtils.getWeekNumber(startDate),\n      startDate,\n      endDate,\n      days\n    };\n  }\n\n  /**\n   * Get day view data\n   * @private\n   */\n  _getDayViewData(date) {\n    const events = this.getEventsForDate(date);\n\n    // Separate all-day and timed events\n    const allDayEvents = events.filter(e => e.allDay);\n    const timedEvents = events.filter(e => !e.allDay);\n\n    // Create hourly slots for timed events\n    const hours = [];\n    for (let hour = 0; hour < 24; hour++) {\n      const hourDate = new Date(date);\n      hourDate.setHours(hour, 0, 0, 0);\n      const hourEnd = new Date(date);\n      hourEnd.setHours(hour + 1, 0, 0, 0);\n\n      hours.push({\n        hour,\n        time: DateUtils.formatTime(hourDate, this.state.get('locale')),\n        events: timedEvents.filter(event => {\n          // Check if event occurs during this hour (not just starts)\n          // Event occurs in this hour if it overlaps with the hour slot\n          return event.start < hourEnd && event.end > hourDate;\n        })\n      });\n    }\n\n    return {\n      type: 'day',\n      date,\n      dayName: DateUtils.getDayName(date, this.state.get('locale')),\n      isToday: DateUtils.isToday(date),\n      allDayEvents,\n      hours\n    };\n  }\n\n  /**\n   * Get list view data\n   * @private\n   */\n  _getListViewData(date) {\n    // Get events for the next 30 days\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n\n    const endDate = new Date(startDate);\n    endDate.setDate(endDate.getDate() + 30);\n\n    const events = this.getEventsInRange(startDate, endDate);\n\n    // Group events by day\n    const groupedEvents = new Map();\n\n    events.forEach(event => {\n      const dateKey = event.start.toDateString();\n      if (!groupedEvents.has(dateKey)) {\n        groupedEvents.set(dateKey, {\n          date: new Date(event.start),\n          events: []\n        });\n      }\n      groupedEvents.get(dateKey).events.push(event);\n    });\n\n    // Convert to sorted array\n    const days = Array.from(groupedEvents.values())\n      .sort((a, b) => a.date - b.date)\n      .map(day => ({\n        ...day,\n        dayName: DateUtils.getDayName(day.date, this.state.get('locale')),\n        isToday: DateUtils.isToday(day.date)\n      }));\n\n    return {\n      type: 'list',\n      startDate,\n      endDate,\n      days,\n      totalEvents: events.length\n    };\n  }\n\n  /**\n   * Select an event\n   * @param {string} eventId - Event ID to select\n   */\n  selectEvent(eventId) {\n    const event = this.getEvent(eventId);\n    if (event) {\n      this.state.selectEvent(eventId);\n      this._emit('eventSelect', { event });\n    }\n  }\n\n  /**\n   * Clear event selection\n   */\n  clearEventSelection() {\n    const eventId = this.state.get('selectedEventId');\n    this.state.clearEventSelection();\n\n    if (eventId) {\n      this._emit('eventDeselect', { eventId });\n    }\n  }\n\n  /**\n   * Select a date\n   * @param {Date} date - Date to select\n   */\n  selectDate(date) {\n    this.state.selectDate(date);\n    this._emit('dateSelect', { date });\n  }\n\n  /**\n   * Clear date selection\n   */\n  clearDateSelection() {\n    const date = this.state.get('selectedDate');\n    this.state.clearDateSelection();\n\n    if (date) {\n      this._emit('dateDeselect', { date });\n    }\n  }\n\n  /**\n   * Subscribe to calendar events\n   * @param {string} eventName - Event name\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  on(eventName, callback) {\n    if (!this.listeners.has(eventName)) {\n      this.listeners.set(eventName, new Set());\n    }\n    this.listeners.get(eventName).add(callback);\n\n    return () => this.off(eventName, callback);\n  }\n\n  /**\n   * Unsubscribe from calendar events\n   * @param {string} eventName - Event name\n   * @param {Function} callback - Callback function\n   */\n  off(eventName, callback) {\n    const callbacks = this.listeners.get(eventName);\n    if (callbacks) {\n      callbacks.delete(callback);\n      if (callbacks.size === 0) {\n        this.listeners.delete(eventName);\n      }\n    }\n  }\n\n  /**\n   * Emit an event\n   * @private\n   */\n  _emit(eventName, data) {\n    const callbacks = this.listeners.get(eventName);\n    if (callbacks) {\n      callbacks.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in event listener for \"${eventName}\":`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Set up internal listeners\n   * @private\n   */\n  _setupInternalListeners() {\n    // Listen to state changes\n    this.state.subscribe((newState, oldState) => {\n      this._emit('stateChange', { newState, oldState });\n    });\n\n    // Listen to event store changes\n    this.eventStore.subscribe((change) => {\n      this._emit('eventStoreChange', change);\n    });\n  }\n\n  /**\n   * Install a plugin\n   * @param {Object} plugin - Plugin object with install method\n   */\n  use(plugin) {\n    if (this.plugins.has(plugin)) {\n      console.warn('Plugin already installed');\n      return;\n    }\n\n    if (typeof plugin.install === 'function') {\n      plugin.install(this);\n      this.plugins.add(plugin);\n    } else {\n      throw new Error('Plugin must have an install method');\n    }\n  }\n\n  /**\n   * Destroy the calendar and clean up\n   */\n  destroy() {\n    // Clear all listeners\n    this.listeners.clear();\n\n    // Clear stores\n    this.eventStore.clear();\n\n    // Clear plugins\n    this.plugins.forEach(plugin => {\n      if (typeof plugin.uninstall === 'function') {\n        plugin.uninstall(this);\n      }\n    });\n    this.plugins.clear();\n\n    this._emit('destroy');\n  }\n}// Test workflow\n","/**\n * Lightning Calendar Core - Main entry point\n * A modern, lightweight, framework-agnostic calendar library\n * Optimized for Salesforce Lightning and Locker Service\n */\n\n// Core exports\nexport { Calendar } from './core/calendar/Calendar.js';\nexport { Event } from './core/events/Event.js';\nexport { EventStore } from './core/events/EventStore.js';\nexport { StateManager } from './core/state/StateManager.js';\nexport { DateUtils } from './core/calendar/DateUtils.js';\n\n// Version\nexport const VERSION = '0.1.0';\n\n// Default export\nexport { Calendar as default } from './core/calendar/Calendar.js';"],"names":["TimezoneManager","constructor","this","offsetCache","Map","dstCache","timezoneAbbreviations","EST","EDT","CST","CDT","MST","MDT","PST","PDT","GMT","BST","CET","CEST","JST","IST","AEST","AEDT","timezoneOffsets","UTC","dstRules","start","month","week","day","end","offset","convertTimezone","date","fromTimezone","toTimezone","Date","fromOffset","getTimezoneOffset","offsetDiff","getTime","toUTC","timezone","fromUTC","utcDate","cacheKey","getFullYear","getMonth","getDate","has","get","Intl","DateTimeFormat","parts","timeZone","year","hour","minute","second","hour12","formatToParts","find","p","type","value","set","e","baseOffset","isDST","dstRule","dstStart","getNthWeekdayOfMonth","dstEnd","dayOfWeek","dayOffset","getDay","setDate","lastDay","getCommonTimezones","now","label","region","map","tz","offsetHours","hours","Math","floor","abs","minutes","round","offsetStr","toString","padStart","offsetMinutes","sort","a","b","formatInTimezone","options","formatOptions","format","toLocaleString","getSystemTimezone","resolvedOptions","tzOffset","Object","entries","parseTimezone","tzString","hasOwnProperty","upperTz","toUpperCase","offsetMatch","match","totalOffset","parseInt","getTimezoneDifference","timezone1","timezone2","offset1","clearCache","clear","Event","normalize","data","normalized","allDay","setHours","id","String","trim","title","description","location","attendees","Array","isArray","reminders","categories","attachments","includes","status","visibility","color","backgroundColor","borderColor","validate","Error","isNaN","recurring","recurrenceRule","length","forEach","attendee","index","email","name","test","reminder","method","minutesBefore","textColor","endTimeZone","organizer","conferenceData","metadata","_timezoneManager","startUTC","endUTC","_originalTimeZone","_cache","_validateAttendees","_validateReminders","duration","getStartInTimezone","getEndInTimezone","updateTimes","durationMinutes","durationHours","isMultiDay","startDay","toDateString","endDay","isRecurring","occursOn","dateString","startString","endString","dayStart","dayEnd","overlaps","otherEvent","contains","datetime","clone","updates","r","toObject","toISOString","fromObject","obj","equals","other","addAttendee","hasAttendee","random","substr","responseStatus","role","push","removeAttendee","emailOrId","findIndex","splice","updateAttendeeResponse","getAttendee","responseTime","some","getAttendeesByStatus","filter","getAttendeeCounts","reduce","counts","addReminder","enabled","removeReminder","reminderId","getActiveReminders","getReminderTriggerTimes","triggerTime","setMinutes","getMinutes","addCategory","category","normalizedCategory","toLowerCase","hasCategory","removeCategory","c","hasAnyCategory","hasAllCategories","every","_isValidEmail","isCancelled","isTentative","isConfirmed","isPrivate","isPublic","hasAttendees","hasReminders","isMeeting","isVirtual","DateUtils","startOfDay","result","endOfDay","startOfWeek","weekStartsOn","diff","setTime","endOfWeek","startOfMonth","endOfMonth","startOfYear","endOfYear","addDays","days","addWeeks","weeks","addMonths","months","dayOfMonth","setMonth","addYears","years","setFullYear","getUTCDateString","getUTCFullYear","getUTCMonth","getUTCDate","getLocalDateString","isToday","today","isPast","isFuture","isSameDay","date1","date2","isSameWeek","week1Start","week2Start","isSameMonth","isSameYear","differenceInDays","differenceInWeeks","differenceInMonths","getWeekNumber","firstDayOfYear","pastDaysOfYear","ceil","getDayOfWeek","getDaysInMonth","locale","getMonthName","getDayName","weekday","formatTime","use24Hour","parseTime","timeString","split","Number","isLeapYear","getDateRange","dates","current","endTime","isValidDate","toTimeZone","dateObj","part","tzDate","jan","jul","janOffset","julOffset","currentOffset","max","addHoursWithDST","originalOffset","newOffset","dstAdjustment","createInTimeZone","dateStr","timeStr","localDate","utcTime","RecurrenceEngine","expandEvent","event","rangeStart","rangeEnd","maxOccurrences","rule","parseRule","occurrences","eventTimezone","tzManager","currentDate","count","until","lastOffset","occurrenceStart","occurrenceEnd","isException","recurringEventId","originalStart","getNextOccurrence","ruleString","freq","interval","byDay","byMonthDay","byMonth","bySetPos","exceptions","key","parseDate","d","m","next","matchesByDay","currentMonth","setToWeekdayOfMonth","dayMap","SU","MO","TU","WE","TH","FR","SA","weekdayCode","position","targetDay","nextMonth","eventId","dateTime","exDate","exceptionDate","matchTime","addExceptions","reason","endsWith","getDescription","join","toLocaleDateString","dayCode","code","LRUCache","capacity","cache","hits","misses","evictions","delete","put","size","firstKey","keys","getStats","hitRate","toFixed","from","PerformanceOptimizer","config","enableCache","cacheCapacity","maxIndexDays","batchSize","enableMetrics","cleanupInterval","maxIndexAge","eventCache","queryCache","dateRangeCache","lazyIndexes","pendingIndexes","batchQueue","batchTimer","batchCallbacks","metrics","operations","averageTimes","slowQueries","cleanupTimer","startCleanupTimer","measure","operation","fn","performance","recordMetric","error","measureAsync","isError","totalTime","errors","min","Infinity","metric","timestamp","shift","getMetrics","summary","cacheStats","query","dateRange","slowestOperations","recentSlowQueries","slice","op","avgTime","minTime","maxTime","errorRate","time","shouldUseLazyIndexing","createLazyIndexMarkers","markers","indexed","Set","pending","startMonth","endMonth","add","getMonthKey","expandLazyIndex","promise","Promise","resolve","setTimeout","cacheType","getFromCache","invalidateEventCaches","batch","reject","processBatch","clearTimeout","callbacks","results","callback","setInterval","cleanupOldIndexes","maxAge","optimizeQuery","queryKey","queryFn","cached","undefined","destroy","clearInterval","ConflictDetector","eventStore","conflictIdCounter","checkConflicts","opts","checkAttendees","checkResources","checkLocation","ignoreAllDay","excludeEventIds","includeStatuses","bufferMinutes","conflicts","affectedEventIds","affectedAttendees","searchStart","searchEnd","potentialConflicts","getEventsInRange","conflictingEvent","eventConflicts","_detectEventConflicts","_buildConflictSummary","checkEventPairConflicts","event1","event2","getBusyPeriods","attendeeEmails","mergePeriods","busyPeriods","eventIds","_mergeBusyPeriods","getFreePeriods","businessHoursOnly","businessHours","excludeWeekends","freePeriods","_getAllBusyPeriods","currentTime","busy","_isWithinBusinessHours","_checkTimeOverlap","timeConflict","_createTimeConflict","attendeeConflicts","_checkAttendeeConflicts","resourceConflicts","_checkResourceConflicts","locationConflict","_checkLocationConflict","buffer","start1","end1","start2","end2","overlapStart","overlapEnd","overlapMinutes","severity","conflictingEventId","event1Title","event2Title","event1Status","event2Status","conflictingAttendees","attendee1","attendee2","a1","a2","attendeeCount","resources1","resource","resources2","resource1","resource2","conflictingResource","resourceName","resourceEmail","conflictsByType","conflictsBySeverity","conflict","hasConflicts","totalConflicts","periods","merged","i","last","startHour","getHours","endHour","businessStart","businessEnd","EventStore","events","indices","byDate","byCategory","byStatus","timezoneManager","defaultTimezone","optimizer","conflictDetector","isBatchMode","batchNotifications","batchBackup","version","listeners","addEvent","_indexEvent","_notifyChange","updateEvent","existingEvent","_unindexEvent","updatedEvent","oldEvent","removeEvent","getEvent","getAllEvents","values","queryEvents","filters","monthKey","matchAllCategories","organizerEmail","localeCompare","getEventsForDate","allEvents","checkDate","tempDate","tempDateStr","eventStartLocal","eventEndLocal","timeCompare","getOverlappingEvents","excludeId","overlapping","startDate","endDate","checkedIds","getOverlapGroups","timedOnly","groups","processed","group","currentEvent","calculateEventPositions","positions","startDiff","columns","column","totalColumns","pos","expandRecurring","baseEvents","expandedEvents","expandRecurringEvent","occurrence","occurrenceIndex","oldEvents","loadEvents","eventData","subscribe","_indexEventLazy","firstWeekEnd","lastWeekStart","change","listener","console","totalEvents","recurringEvents","indexedDates","indexedMonths","indexedCategories","indexedStatuses","performanceMetrics","startBatch","enableRollback","k","v","commitBatch","changes","rollbackBatch","executeBatch","addEvents","message","warn","updateEvents","eventUpdates","removeEvents","removed","getPerformanceMetrics","clearCaches","optimizeIndices","cutoffDate","stillNeeded","log","eventId1","eventId2","getAllConflicts","allConflicts","checkedPairs","j","pairKey","addEventWithConflictCheck","allowConflicts","findEventsWithConflicts","eventsWithConflicts","StateManager","initialState","state","view","selectedEventId","selectedDate","hoveredEventId","hoveredDate","showWeekNumbers","showWeekends","fixedWeekCount","hourFormat","searchTerm","showAllDay","showTimed","isDragging","isResizing","isCreating","isLoading","loadingMessage","globalListeners","history","historyIndex","maxHistorySize","getState","freeze","setState","oldState","newState","_hasChanged","_addToHistory","_notifyListeners","setView","validViews","setCurrentDate","navigateNext","newDate","navigatePrevious","navigateToday","selectEvent","clearEventSelection","selectDate","clearDateSelection","setLoading","setError","updateFilters","watch","keyArray","canUndo","canRedo","getUndoCount","getRedoCount","undo","previousState","currentState","redo","nextState","reset","_deepEqual","seen","aKeys","bKeys","Calendar","plugins","views","_setupInternalListeners","setEvents","viewType","_emit","getView","direction","previous","goToDate","getCurrentDate","getEvents","setTimezone","parsedTimezone","previousTimezone","getTimezone","toCalendarTimezone","fromCalendarTimezone","getTimezones","getViewData","_getMonthViewData","_getWeekViewData","_getDayViewData","_getListViewData","firstDay","maxWeeks","weekIndex","weekNumber","dayIndex","dayDate","isCurrentMonth","isWeekend","monthName","dayName","overlapGroups","getEventPositions","allDayEvents","timedEvents","hourDate","hourEnd","groupedEvents","dateKey","on","eventName","off","use","plugin","install","uninstall","VERSION"],"mappings":"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"}